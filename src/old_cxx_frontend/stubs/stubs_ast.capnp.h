// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: stubs_ast.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 9001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(b1436df23fb200b4);
CAPNP_DECLARE_SCHEMA(80bc3ef5a3c049a0);
CAPNP_DECLARE_SCHEMA(e2a8b78aa50d684a);
CAPNP_DECLARE_SCHEMA(adb9aafdab430c1d);
CAPNP_DECLARE_SCHEMA(b32068af6baf8c74);
enum class RecordKind_b32068af6baf8c74: uint16_t {
  STRUC,
  CLASS,
  UNIO,
};
CAPNP_DECLARE_ENUM(RecordKind, b32068af6baf8c74);
CAPNP_DECLARE_SCHEMA(ec96558d3909990f);
CAPNP_DECLARE_SCHEMA(ab35d5180cf244f1);
CAPNP_DECLARE_SCHEMA(f4d8929c89991d82);
CAPNP_DECLARE_SCHEMA(a55569ca8e443a2d);
enum class BuiltinKind_a55569ca8e443a2d: uint16_t {
  CHAR,
  U_CHAR,
  SHORT,
  U_SHORT,
  VOID,
  BOOL,
  INT,
  U_INT,
  LONG,
  U_LONG,
  LONG_LONG,
  U_LONG_LONG,
};
CAPNP_DECLARE_ENUM(BuiltinKind, a55569ca8e443a2d);
CAPNP_DECLARE_SCHEMA(90f48d4b27818920);
CAPNP_DECLARE_SCHEMA(ca177508e12edb53);
enum class FixedWidthKind_ca177508e12edb53: uint16_t {
  INT,
  U_INT,
};
CAPNP_DECLARE_ENUM(FixedWidthKind, ca177508e12edb53);
CAPNP_DECLARE_SCHEMA(fa3f1e437e0e73dc);
CAPNP_DECLARE_SCHEMA(f6a0f771ad50816c);
CAPNP_DECLARE_SCHEMA(fe7af58e3af28b84);
CAPNP_DECLARE_SCHEMA(bfef959001088175);
CAPNP_DECLARE_SCHEMA(899b868295a7b9ce);
CAPNP_DECLARE_SCHEMA(ef7716d0539edb37);
CAPNP_DECLARE_SCHEMA(d41d9dffe36da558);
CAPNP_DECLARE_SCHEMA(ef0bcc479ff59f3e);
CAPNP_DECLARE_SCHEMA(ffc6828955aafac4);
CAPNP_DECLARE_SCHEMA(d96c7f8624e22938);
CAPNP_DECLARE_SCHEMA(8da2907bb130c41c);
CAPNP_DECLARE_SCHEMA(d4208da29139e6b6);
enum class InitStyle_d4208da29139e6b6: uint16_t {
  C_INIT,
  CALL_INIT,
  LIST_INIT,
};
CAPNP_DECLARE_ENUM(InitStyle, d4208da29139e6b6);
CAPNP_DECLARE_SCHEMA(96ff0430cb165092);
CAPNP_DECLARE_SCHEMA(d64c65470b140c81);
CAPNP_DECLARE_SCHEMA(ca43d1968400194b);
CAPNP_DECLARE_SCHEMA(beab445407716936);
enum class InitStyle_beab445407716936: uint16_t {
  COPY_INIT,
  LIST_INIT,
};
CAPNP_DECLARE_ENUM(InitStyle, beab445407716936);
CAPNP_DECLARE_SCHEMA(91afac6d2dc82432);
CAPNP_DECLARE_SCHEMA(c925b09644ce72d3);
CAPNP_DECLARE_SCHEMA(9ffaae697f26648e);
CAPNP_DECLARE_SCHEMA(d26ea0ac04b0689b);
CAPNP_DECLARE_SCHEMA(bebeef9161eb7d3c);
CAPNP_DECLARE_SCHEMA(e1a2673f5339803f);
CAPNP_DECLARE_SCHEMA(f64598c2842483ec);
CAPNP_DECLARE_SCHEMA(a31fa1100c324f2f);
CAPNP_DECLARE_SCHEMA(88d58127ebcf6085);
CAPNP_DECLARE_SCHEMA(e46ae190d3365bca);
CAPNP_DECLARE_SCHEMA(daecdb4dcd868ea8);
CAPNP_DECLARE_SCHEMA(87676bdbadd4545d);
CAPNP_DECLARE_SCHEMA(92f4588bb5c5df26);
CAPNP_DECLARE_SCHEMA(f8e83450e2ea65bc);
CAPNP_DECLARE_SCHEMA(e1ccba681f3b88c6);
enum class UnaryOpKind_e1ccba681f3b88c6: uint16_t {
  PLUS,
  MINUS,
  NOT,
  L_NOT,
  ADDR_OF,
  DEREF,
  PRE_INC,
  PRE_DEC,
  POST_INC,
  POST_DEC,
};
CAPNP_DECLARE_ENUM(UnaryOpKind, e1ccba681f3b88c6);
CAPNP_DECLARE_SCHEMA(daee06933175bc05);
enum class BinaryOpKind_daee06933175bc05: uint16_t {
  ADD,
  SUB,
  ASSIGN,
  MUL,
  DIV,
  REM,
  SHL,
  SHR,
  LT,
  GT,
  LE,
  GE,
  EQ,
  NE,
  AND,
  OR,
  XOR,
  L_AND,
  L_OR,
  MUL_ASSIGN,
  DIV_ASSIGN,
  REM_ASSIGN,
  ADD_ASSIGN,
  SUB_ASSIGN,
  SHL_ASSIGN,
  SHR_ASSIGN,
  AND_ASSIGN,
  XOR_ASSIGN,
  OR_ASSIGN,
};
CAPNP_DECLARE_ENUM(BinaryOpKind, daee06933175bc05);
CAPNP_DECLARE_SCHEMA(8fa195ee3833f42e);
enum class SufKind_8fa195ee3833f42e: uint16_t {
  L_SUF,
  L_L_SUF,
  NO_SUF,
};
CAPNP_DECLARE_ENUM(SufKind, 8fa195ee3833f42e);
CAPNP_DECLARE_SCHEMA(da936a12fe3023f7);
enum class NbBase_da936a12fe3023f7: uint16_t {
  DECIMAL,
  OCTAL,
  HEX,
};
CAPNP_DECLARE_ENUM(NbBase, da936a12fe3023f7);
CAPNP_DECLARE_SCHEMA(d5d009cc85c86562);
CAPNP_DECLARE_SCHEMA(b525d86a8f48e679);
CAPNP_DECLARE_SCHEMA(b95e9a5df08d277c);
CAPNP_DECLARE_SCHEMA(a21731ff472a9631);
CAPNP_DECLARE_SCHEMA(d6c567dfeede9b58);
CAPNP_DECLARE_SCHEMA(a4d76185fab22f27);
CAPNP_DECLARE_SCHEMA(ab509764d68e7721);
CAPNP_DECLARE_SCHEMA(e0dbc3751d359960);
CAPNP_DECLARE_SCHEMA(9094c5b59016772f);
CAPNP_DECLARE_SCHEMA(a6587e392992550d);
CAPNP_DECLARE_SCHEMA(ad2f528afe2c7941);
CAPNP_DECLARE_SCHEMA(98b043b3eb527a16);
CAPNP_DECLARE_SCHEMA(8ae30723c7f4eeb7);
CAPNP_DECLARE_SCHEMA(c63033d95787d2ff);
CAPNP_DECLARE_SCHEMA(9162b284a3cba818);
CAPNP_DECLARE_SCHEMA(a924c04c2f68f445);
CAPNP_DECLARE_SCHEMA(a5cc2b3709c2654d);

}  // namespace schemas
}  // namespace capnp

namespace stubs {

struct Loc {
  Loc() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct SrcPos;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b1436df23fb200b4, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Loc::SrcPos {
  SrcPos() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(80bc3ef5a3c049a0, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename Base = ::capnp::AnyPointer>
struct Node {
  Node() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e2a8b78aa50d684a, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Base>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct Clause {
  Clause() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(adb9aafdab430c1d, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

typedef ::capnp::schemas::RecordKind_b32068af6baf8c74 RecordKind;

struct RecordRef {
  RecordRef() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ec96558d3909990f, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Param {
  Param() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ab35d5180cf244f1, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Type {
  Type() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNION_NOT_INITIALIZED,
    BUILTIN,
    POINTER,
    RECORD,
    ENUM_TYPE,
    L_VALUE_REF,
    R_VALUE_REF,
    FIXED_WIDTH,
    ELABORATED,
    TYPEDEF,
    FUNCTION_PROTO,
    SUBST_TEMPLATE_TYPE_PARAM,
  };
  typedef ::capnp::schemas::BuiltinKind_a55569ca8e443a2d BuiltinKind;

  struct FixedWidth;
  struct FunctionProto;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f4d8929c89991d82, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Type::FixedWidth {
  FixedWidth() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::FixedWidthKind_ca177508e12edb53 FixedWidthKind;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(90f48d4b27818920, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Type::FunctionProto {
  FunctionProto() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa3f1e437e0e73dc, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Stmt {
  Stmt() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNION_NOT_INITIALIZED,
    ANN,
    DECL,
    COMPOUND,
    EXPR,
    RETURN,
    IF,
    NULL_,
    WHILE,
    DO_WHILE,
    BREAK,
    CONTINUE,
    SWITCH,
    CASE,
    DEF_CASE,
  };
  struct Return;
  struct If;
  struct Compound;
  struct While;
  struct Case;
  struct DefCase;
  struct Switch;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f6a0f771ad50816c, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Stmt::Return {
  Return() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe7af58e3af28b84, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Stmt::If {
  If() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bfef959001088175, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Stmt::Compound {
  Compound() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(899b868295a7b9ce, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Stmt::While {
  While() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ef7716d0539edb37, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Stmt::Case {
  Case() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d41d9dffe36da558, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Stmt::DefCase {
  DefCase() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ef0bcc479ff59f3e, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Stmt::Switch {
  Switch() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ffc6828955aafac4, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl {
  Decl() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNION_NOT_INITIALIZED,
    ANN,
    EMPTY,
    VAR,
    FUNCTION,
    FIELD,
    RECORD,
    METHOD,
    ACCESS_SPEC,
    CTOR,
    DTOR,
    TYPEDEF,
    ENUM_DECL,
    NAMESPACE,
    FUNCTION_TEMPLATE,
  };
  struct Var;
  struct Function;
  struct Field;
  struct Record;
  struct Method;
  struct Ctor;
  struct Dtor;
  struct Typedef;
  struct Enum;
  struct Namespace;
  struct FunctionTemplate;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d96c7f8624e22938, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Var {
  Var() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::InitStyle_d4208da29139e6b6 InitStyle;

  struct VarInit;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8da2907bb130c41c, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Var::VarInit {
  VarInit() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(96ff0430cb165092, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Function {
  Function() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d64c65470b140c81, 0, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Field {
  Field() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::InitStyle_beab445407716936 InitStyle;

  struct FieldInit;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ca43d1968400194b, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Field::FieldInit {
  FieldInit() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(91afac6d2dc82432, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Record {
  Record() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct BaseSpec;
  struct Body;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c925b09644ce72d3, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Record::BaseSpec {
  BaseSpec() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ffaae697f26648e, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Record::Body {
  Body() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d26ea0ac04b0689b, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Method {
  Method() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Override;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bebeef9161eb7d3c, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Method::Override {
  Override() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e1a2673f5339803f, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Ctor {
  Ctor() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct CtorInit;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f64598c2842483ec, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Ctor::CtorInit {
  CtorInit() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a31fa1100c324f2f, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Dtor {
  Dtor() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(88d58127ebcf6085, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Typedef {
  Typedef() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e46ae190d3365bca, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Enum {
  Enum() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct EnumField;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(daecdb4dcd868ea8, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Enum::EnumField {
  EnumField() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(87676bdbadd4545d, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::Namespace {
  Namespace() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(92f4588bb5c5df26, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Decl::FunctionTemplate {
  FunctionTemplate() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f8e83450e2ea65bc, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

typedef ::capnp::schemas::UnaryOpKind_e1ccba681f3b88c6 UnaryOpKind;

typedef ::capnp::schemas::BinaryOpKind_daee06933175bc05 BinaryOpKind;

typedef ::capnp::schemas::SufKind_8fa195ee3833f42e SufKind;

typedef ::capnp::schemas::NbBase_da936a12fe3023f7 NbBase;

struct Expr {
  Expr() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNION_NOT_INITIALIZED,
    UNARY_OP,
    BINARY_OP,
    BOOL_LIT,
    INT_LIT,
    STRING_LIT,
    CALL,
    DECL_REF,
    MEMBER,
    THIS,
    MEMBER_CALL,
    NEW,
    CONSTRUCT,
    NULL_PTR_LIT,
    DELETE,
    TRUNCATING,
    L_VALUE_TO_R_VALUE,
    DERIVED_TO_BASE,
    BASE_TO_DERIVED,
    OPERATOR_CALL,
  };
  struct UnaryOp;
  struct BinaryOp;
  struct IntLit;
  struct Call;
  struct MemberCall;
  struct Member;
  struct New;
  struct Construct;
  struct StructToStruct;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d5d009cc85c86562, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Expr::UnaryOp {
  UnaryOp() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b525d86a8f48e679, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Expr::BinaryOp {
  BinaryOp() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b95e9a5df08d277c, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Expr::IntLit {
  IntLit() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a21731ff472a9631, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Expr::Call {
  Call() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d6c567dfeede9b58, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Expr::MemberCall {
  MemberCall() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a4d76185fab22f27, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Expr::Member {
  Member() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ab509764d68e7721, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Expr::New {
  New() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e0dbc3751d359960, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Expr::Construct {
  Construct() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9094c5b59016772f, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Expr::StructToStruct {
  StructToStruct() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a6587e392992550d, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Include {
  Include() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNION_NOT_INITIALIZED,
    REAL_INCLUDE,
    GHOST_INCLUDE,
  };
  struct RealInclude;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ad2f528afe2c7941, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Include::RealInclude {
  RealInclude() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(98b043b3eb527a16, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct File {
  File() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8ae30723c7f4eeb7, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TU {
  TU() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c63033d95787d2ff, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Err {
  Err() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9162b284a3cba818, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct VfError {
  VfError() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a924c04c2f68f445, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SerResult {
  SerResult() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    OK,
    CLANG_ERROR,
    VF_ERROR,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a5cc2b3709c2654d, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Loc::Reader {
public:
  typedef Loc Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasStart() const;
  inline  ::stubs::Loc::SrcPos::Reader getStart() const;

  inline bool hasEnd() const;
  inline  ::stubs::Loc::SrcPos::Reader getEnd() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Loc::Builder {
public:
  typedef Loc Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasStart();
  inline  ::stubs::Loc::SrcPos::Builder getStart();
  inline void setStart( ::stubs::Loc::SrcPos::Reader value);
  inline  ::stubs::Loc::SrcPos::Builder initStart();
  inline void adoptStart(::capnp::Orphan< ::stubs::Loc::SrcPos>&& value);
  inline ::capnp::Orphan< ::stubs::Loc::SrcPos> disownStart();

  inline bool hasEnd();
  inline  ::stubs::Loc::SrcPos::Builder getEnd();
  inline void setEnd( ::stubs::Loc::SrcPos::Reader value);
  inline  ::stubs::Loc::SrcPos::Builder initEnd();
  inline void adoptEnd(::capnp::Orphan< ::stubs::Loc::SrcPos>&& value);
  inline ::capnp::Orphan< ::stubs::Loc::SrcPos> disownEnd();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Loc::Pipeline {
public:
  typedef Loc Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Loc::SrcPos::Pipeline getStart();
  inline  ::stubs::Loc::SrcPos::Pipeline getEnd();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Loc::SrcPos::Reader {
public:
  typedef SrcPos Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getL() const;

  inline  ::uint16_t getC() const;

  inline  ::uint16_t getFd() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Loc::SrcPos::Builder {
public:
  typedef SrcPos Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getL();
  inline void setL( ::uint16_t value);

  inline  ::uint16_t getC();
  inline void setC( ::uint16_t value);

  inline  ::uint16_t getFd();
  inline void setFd( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Loc::SrcPos::Pipeline {
public:
  typedef SrcPos Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Base>
class Node<Base>::Reader {
public:
  typedef Node Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Base2 = ::capnp::AnyPointer>
  typename Node<Base2>::Reader asGeneric() {
    return typename Node<Base2>::Reader(_reader);
  }

  inline bool hasLoc() const;
  inline  ::stubs::Loc::Reader getLoc() const;

  inline bool hasDesc() const;
  inline  ::capnp::ReaderFor<Base> getDesc() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Base>
class Node<Base>::Builder {
public:
  typedef Node Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Base2 = ::capnp::AnyPointer>
  typename Node<Base2>::Builder asGeneric() {
    return typename Node<Base2>::Builder(_builder);
  }

  inline bool hasLoc();
  inline  ::stubs::Loc::Builder getLoc();
  inline void setLoc( ::stubs::Loc::Reader value);
  inline  ::stubs::Loc::Builder initLoc();
  inline void adoptLoc(::capnp::Orphan< ::stubs::Loc>&& value);
  inline ::capnp::Orphan< ::stubs::Loc> disownLoc();

  inline bool hasDesc();
  inline  ::capnp::BuilderFor<Base> getDesc();
  inline void setDesc( ::capnp::ReaderFor<Base> value);
  inline  ::capnp::BuilderFor<Base> initDesc();
  inline  ::capnp::BuilderFor<Base> initDesc(unsigned int size);
  inline void adoptDesc(::capnp::Orphan<Base>&& value);
  inline ::capnp::Orphan<Base> disownDesc();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Base>
class Node<Base>::Pipeline {
public:
  typedef Node Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Loc::Pipeline getLoc();
  inline  ::capnp::PipelineFor<Base> getDesc();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Clause::Reader {
public:
  typedef Clause Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLoc() const;
  inline  ::stubs::Loc::Reader getLoc() const;

  inline bool hasText() const;
  inline  ::capnp::Text::Reader getText() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Clause::Builder {
public:
  typedef Clause Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLoc();
  inline  ::stubs::Loc::Builder getLoc();
  inline void setLoc( ::stubs::Loc::Reader value);
  inline  ::stubs::Loc::Builder initLoc();
  inline void adoptLoc(::capnp::Orphan< ::stubs::Loc>&& value);
  inline ::capnp::Orphan< ::stubs::Loc> disownLoc();

  inline bool hasText();
  inline  ::capnp::Text::Builder getText();
  inline void setText( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initText(unsigned int size);
  inline void adoptText(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownText();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Clause::Pipeline {
public:
  typedef Clause Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Loc::Pipeline getLoc();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RecordRef::Reader {
public:
  typedef RecordRef Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::stubs::RecordKind getKind() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RecordRef::Builder {
public:
  typedef RecordRef Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::stubs::RecordKind getKind();
  inline void setKind( ::stubs::RecordKind value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RecordRef::Pipeline {
public:
  typedef RecordRef Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Param::Reader {
public:
  typedef Param Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasType() const;
  inline  ::stubs::Node< ::stubs::Type>::Reader getType() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasDefault() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getDefault() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Param::Builder {
public:
  typedef Param Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasType();
  inline  ::stubs::Node< ::stubs::Type>::Builder getType();
  inline void setType( ::stubs::Node< ::stubs::Type>::Reader value);
  inline  ::stubs::Node< ::stubs::Type>::Builder initType();
  inline void adoptType(::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> disownType();

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasDefault();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getDefault();
  inline void setDefault( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initDefault();
  inline void adoptDefault(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownDefault();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Param::Pipeline {
public:
  typedef Param Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Type>::Pipeline getType();
  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getDefault();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Type::Reader {
public:
  typedef Type Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnionNotInitialized() const;
  inline  ::capnp::Void getUnionNotInitialized() const;

  inline bool isBuiltin() const;
  inline  ::stubs::Type::BuiltinKind getBuiltin() const;

  inline bool isPointer() const;
  inline bool hasPointer() const;
  inline  ::stubs::Node< ::stubs::Type>::Reader getPointer() const;

  inline bool isRecord() const;
  inline bool hasRecord() const;
  inline  ::stubs::RecordRef::Reader getRecord() const;

  inline bool isEnumType() const;
  inline bool hasEnumType() const;
  inline  ::capnp::Text::Reader getEnumType() const;

  inline bool isLValueRef() const;
  inline bool hasLValueRef() const;
  inline  ::stubs::Node< ::stubs::Type>::Reader getLValueRef() const;

  inline bool isRValueRef() const;
  inline bool hasRValueRef() const;
  inline  ::stubs::Node< ::stubs::Type>::Reader getRValueRef() const;

  inline bool isFixedWidth() const;
  inline bool hasFixedWidth() const;
  inline  ::stubs::Type::FixedWidth::Reader getFixedWidth() const;

  inline bool isElaborated() const;
  inline bool hasElaborated() const;
  inline  ::stubs::Node< ::stubs::Type>::Reader getElaborated() const;

  inline bool isTypedef() const;
  inline bool hasTypedef() const;
  inline  ::capnp::Text::Reader getTypedef() const;

  inline bool isFunctionProto() const;
  inline bool hasFunctionProto() const;
  inline  ::stubs::Type::FunctionProto::Reader getFunctionProto() const;

  inline bool isSubstTemplateTypeParam() const;
  inline bool hasSubstTemplateTypeParam() const;
  inline  ::stubs::Node< ::stubs::Type>::Reader getSubstTemplateTypeParam() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Type::Builder {
public:
  typedef Type Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnionNotInitialized();
  inline  ::capnp::Void getUnionNotInitialized();
  inline void setUnionNotInitialized( ::capnp::Void value = ::capnp::VOID);

  inline bool isBuiltin();
  inline  ::stubs::Type::BuiltinKind getBuiltin();
  inline void setBuiltin( ::stubs::Type::BuiltinKind value);

  inline bool isPointer();
  inline bool hasPointer();
  inline  ::stubs::Node< ::stubs::Type>::Builder getPointer();
  inline void setPointer( ::stubs::Node< ::stubs::Type>::Reader value);
  inline  ::stubs::Node< ::stubs::Type>::Builder initPointer();
  inline void adoptPointer(::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> disownPointer();

  inline bool isRecord();
  inline bool hasRecord();
  inline  ::stubs::RecordRef::Builder getRecord();
  inline void setRecord( ::stubs::RecordRef::Reader value);
  inline  ::stubs::RecordRef::Builder initRecord();
  inline void adoptRecord(::capnp::Orphan< ::stubs::RecordRef>&& value);
  inline ::capnp::Orphan< ::stubs::RecordRef> disownRecord();

  inline bool isEnumType();
  inline bool hasEnumType();
  inline  ::capnp::Text::Builder getEnumType();
  inline void setEnumType( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initEnumType(unsigned int size);
  inline void adoptEnumType(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownEnumType();

  inline bool isLValueRef();
  inline bool hasLValueRef();
  inline  ::stubs::Node< ::stubs::Type>::Builder getLValueRef();
  inline void setLValueRef( ::stubs::Node< ::stubs::Type>::Reader value);
  inline  ::stubs::Node< ::stubs::Type>::Builder initLValueRef();
  inline void adoptLValueRef(::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> disownLValueRef();

  inline bool isRValueRef();
  inline bool hasRValueRef();
  inline  ::stubs::Node< ::stubs::Type>::Builder getRValueRef();
  inline void setRValueRef( ::stubs::Node< ::stubs::Type>::Reader value);
  inline  ::stubs::Node< ::stubs::Type>::Builder initRValueRef();
  inline void adoptRValueRef(::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> disownRValueRef();

  inline bool isFixedWidth();
  inline bool hasFixedWidth();
  inline  ::stubs::Type::FixedWidth::Builder getFixedWidth();
  inline void setFixedWidth( ::stubs::Type::FixedWidth::Reader value);
  inline  ::stubs::Type::FixedWidth::Builder initFixedWidth();
  inline void adoptFixedWidth(::capnp::Orphan< ::stubs::Type::FixedWidth>&& value);
  inline ::capnp::Orphan< ::stubs::Type::FixedWidth> disownFixedWidth();

  inline bool isElaborated();
  inline bool hasElaborated();
  inline  ::stubs::Node< ::stubs::Type>::Builder getElaborated();
  inline void setElaborated( ::stubs::Node< ::stubs::Type>::Reader value);
  inline  ::stubs::Node< ::stubs::Type>::Builder initElaborated();
  inline void adoptElaborated(::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> disownElaborated();

  inline bool isTypedef();
  inline bool hasTypedef();
  inline  ::capnp::Text::Builder getTypedef();
  inline void setTypedef( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initTypedef(unsigned int size);
  inline void adoptTypedef(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownTypedef();

  inline bool isFunctionProto();
  inline bool hasFunctionProto();
  inline  ::stubs::Type::FunctionProto::Builder getFunctionProto();
  inline void setFunctionProto( ::stubs::Type::FunctionProto::Reader value);
  inline  ::stubs::Type::FunctionProto::Builder initFunctionProto();
  inline void adoptFunctionProto(::capnp::Orphan< ::stubs::Type::FunctionProto>&& value);
  inline ::capnp::Orphan< ::stubs::Type::FunctionProto> disownFunctionProto();

  inline bool isSubstTemplateTypeParam();
  inline bool hasSubstTemplateTypeParam();
  inline  ::stubs::Node< ::stubs::Type>::Builder getSubstTemplateTypeParam();
  inline void setSubstTemplateTypeParam( ::stubs::Node< ::stubs::Type>::Reader value);
  inline  ::stubs::Node< ::stubs::Type>::Builder initSubstTemplateTypeParam();
  inline void adoptSubstTemplateTypeParam(::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> disownSubstTemplateTypeParam();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Type::Pipeline {
public:
  typedef Type Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Type::FixedWidth::Reader {
public:
  typedef FixedWidth Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::stubs::Type::FixedWidth::FixedWidthKind getKind() const;

  inline  ::uint8_t getBits() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Type::FixedWidth::Builder {
public:
  typedef FixedWidth Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::stubs::Type::FixedWidth::FixedWidthKind getKind();
  inline void setKind( ::stubs::Type::FixedWidth::FixedWidthKind value);

  inline  ::uint8_t getBits();
  inline void setBits( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Type::FixedWidth::Pipeline {
public:
  typedef FixedWidth Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Type::FunctionProto::Reader {
public:
  typedef FunctionProto Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasReturnType() const;
  inline  ::stubs::Node< ::stubs::Type>::Reader getReturnType() const;

  inline bool hasGhostParams() const;
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader getGhostParams() const;

  inline bool hasParams() const;
  inline  ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Reader getParams() const;

  inline bool hasContract() const;
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader getContract() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Type::FunctionProto::Builder {
public:
  typedef FunctionProto Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasReturnType();
  inline  ::stubs::Node< ::stubs::Type>::Builder getReturnType();
  inline void setReturnType( ::stubs::Node< ::stubs::Type>::Reader value);
  inline  ::stubs::Node< ::stubs::Type>::Builder initReturnType();
  inline void adoptReturnType(::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> disownReturnType();

  inline bool hasGhostParams();
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder getGhostParams();
  inline void setGhostParams( ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder initGhostParams(unsigned int size);
  inline void adoptGhostParams(::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>> disownGhostParams();

  inline bool hasParams();
  inline  ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Builder getParams();
  inline void setParams( ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Builder initParams(unsigned int size);
  inline void adoptParams(::capnp::Orphan< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>> disownParams();

  inline bool hasContract();
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder getContract();
  inline void setContract( ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder initContract(unsigned int size);
  inline void adoptContract(::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>> disownContract();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Type::FunctionProto::Pipeline {
public:
  typedef FunctionProto Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Type>::Pipeline getReturnType();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Stmt::Reader {
public:
  typedef Stmt Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnionNotInitialized() const;
  inline  ::capnp::Void getUnionNotInitialized() const;

  inline bool isAnn() const;
  inline bool hasAnn() const;
  inline  ::capnp::Text::Reader getAnn() const;

  inline bool isDecl() const;
  inline bool hasDecl() const;
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader getDecl() const;

  inline bool isCompound() const;
  inline bool hasCompound() const;
  inline  ::stubs::Stmt::Compound::Reader getCompound() const;

  inline bool isExpr() const;
  inline bool hasExpr() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getExpr() const;

  inline bool isReturn() const;
  inline bool hasReturn() const;
  inline  ::stubs::Stmt::Return::Reader getReturn() const;

  inline bool isIf() const;
  inline bool hasIf() const;
  inline  ::stubs::Stmt::If::Reader getIf() const;

  inline bool isNull() const;
  inline  ::capnp::Void getNull() const;

  inline bool isWhile() const;
  inline bool hasWhile() const;
  inline  ::stubs::Stmt::While::Reader getWhile() const;

  inline bool isDoWhile() const;
  inline bool hasDoWhile() const;
  inline  ::stubs::Stmt::While::Reader getDoWhile() const;

  inline bool isBreak() const;
  inline  ::capnp::Void getBreak() const;

  inline bool isContinue() const;
  inline  ::capnp::Void getContinue() const;

  inline bool isSwitch() const;
  inline bool hasSwitch() const;
  inline  ::stubs::Stmt::Switch::Reader getSwitch() const;

  inline bool isCase() const;
  inline bool hasCase() const;
  inline  ::stubs::Stmt::Case::Reader getCase() const;

  inline bool isDefCase() const;
  inline bool hasDefCase() const;
  inline  ::stubs::Stmt::DefCase::Reader getDefCase() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stmt::Builder {
public:
  typedef Stmt Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnionNotInitialized();
  inline  ::capnp::Void getUnionNotInitialized();
  inline void setUnionNotInitialized( ::capnp::Void value = ::capnp::VOID);

  inline bool isAnn();
  inline bool hasAnn();
  inline  ::capnp::Text::Builder getAnn();
  inline void setAnn( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initAnn(unsigned int size);
  inline void adoptAnn(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownAnn();

  inline bool isDecl();
  inline bool hasDecl();
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder getDecl();
  inline void setDecl( ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder initDecl(unsigned int size);
  inline void adoptDecl(::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>> disownDecl();

  inline bool isCompound();
  inline bool hasCompound();
  inline  ::stubs::Stmt::Compound::Builder getCompound();
  inline void setCompound( ::stubs::Stmt::Compound::Reader value);
  inline  ::stubs::Stmt::Compound::Builder initCompound();
  inline void adoptCompound(::capnp::Orphan< ::stubs::Stmt::Compound>&& value);
  inline ::capnp::Orphan< ::stubs::Stmt::Compound> disownCompound();

  inline bool isExpr();
  inline bool hasExpr();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getExpr();
  inline void setExpr( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initExpr();
  inline void adoptExpr(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownExpr();

  inline bool isReturn();
  inline bool hasReturn();
  inline  ::stubs::Stmt::Return::Builder getReturn();
  inline void setReturn( ::stubs::Stmt::Return::Reader value);
  inline  ::stubs::Stmt::Return::Builder initReturn();
  inline void adoptReturn(::capnp::Orphan< ::stubs::Stmt::Return>&& value);
  inline ::capnp::Orphan< ::stubs::Stmt::Return> disownReturn();

  inline bool isIf();
  inline bool hasIf();
  inline  ::stubs::Stmt::If::Builder getIf();
  inline void setIf( ::stubs::Stmt::If::Reader value);
  inline  ::stubs::Stmt::If::Builder initIf();
  inline void adoptIf(::capnp::Orphan< ::stubs::Stmt::If>&& value);
  inline ::capnp::Orphan< ::stubs::Stmt::If> disownIf();

  inline bool isNull();
  inline  ::capnp::Void getNull();
  inline void setNull( ::capnp::Void value = ::capnp::VOID);

  inline bool isWhile();
  inline bool hasWhile();
  inline  ::stubs::Stmt::While::Builder getWhile();
  inline void setWhile( ::stubs::Stmt::While::Reader value);
  inline  ::stubs::Stmt::While::Builder initWhile();
  inline void adoptWhile(::capnp::Orphan< ::stubs::Stmt::While>&& value);
  inline ::capnp::Orphan< ::stubs::Stmt::While> disownWhile();

  inline bool isDoWhile();
  inline bool hasDoWhile();
  inline  ::stubs::Stmt::While::Builder getDoWhile();
  inline void setDoWhile( ::stubs::Stmt::While::Reader value);
  inline  ::stubs::Stmt::While::Builder initDoWhile();
  inline void adoptDoWhile(::capnp::Orphan< ::stubs::Stmt::While>&& value);
  inline ::capnp::Orphan< ::stubs::Stmt::While> disownDoWhile();

  inline bool isBreak();
  inline  ::capnp::Void getBreak();
  inline void setBreak( ::capnp::Void value = ::capnp::VOID);

  inline bool isContinue();
  inline  ::capnp::Void getContinue();
  inline void setContinue( ::capnp::Void value = ::capnp::VOID);

  inline bool isSwitch();
  inline bool hasSwitch();
  inline  ::stubs::Stmt::Switch::Builder getSwitch();
  inline void setSwitch( ::stubs::Stmt::Switch::Reader value);
  inline  ::stubs::Stmt::Switch::Builder initSwitch();
  inline void adoptSwitch(::capnp::Orphan< ::stubs::Stmt::Switch>&& value);
  inline ::capnp::Orphan< ::stubs::Stmt::Switch> disownSwitch();

  inline bool isCase();
  inline bool hasCase();
  inline  ::stubs::Stmt::Case::Builder getCase();
  inline void setCase( ::stubs::Stmt::Case::Reader value);
  inline  ::stubs::Stmt::Case::Builder initCase();
  inline void adoptCase(::capnp::Orphan< ::stubs::Stmt::Case>&& value);
  inline ::capnp::Orphan< ::stubs::Stmt::Case> disownCase();

  inline bool isDefCase();
  inline bool hasDefCase();
  inline  ::stubs::Stmt::DefCase::Builder getDefCase();
  inline void setDefCase( ::stubs::Stmt::DefCase::Reader value);
  inline  ::stubs::Stmt::DefCase::Builder initDefCase();
  inline void adoptDefCase(::capnp::Orphan< ::stubs::Stmt::DefCase>&& value);
  inline ::capnp::Orphan< ::stubs::Stmt::DefCase> disownDefCase();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stmt::Pipeline {
public:
  typedef Stmt Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Stmt::Return::Reader {
public:
  typedef Return Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasExpr() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getExpr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stmt::Return::Builder {
public:
  typedef Return Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasExpr();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getExpr();
  inline void setExpr( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initExpr();
  inline void adoptExpr(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownExpr();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stmt::Return::Pipeline {
public:
  typedef Return Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getExpr();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Stmt::If::Reader {
public:
  typedef If Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCond() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getCond() const;

  inline bool hasThen() const;
  inline  ::stubs::Node< ::stubs::Stmt>::Reader getThen() const;

  inline bool hasElse() const;
  inline  ::stubs::Node< ::stubs::Stmt>::Reader getElse() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stmt::If::Builder {
public:
  typedef If Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCond();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getCond();
  inline void setCond( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initCond();
  inline void adoptCond(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownCond();

  inline bool hasThen();
  inline  ::stubs::Node< ::stubs::Stmt>::Builder getThen();
  inline void setThen( ::stubs::Node< ::stubs::Stmt>::Reader value);
  inline  ::stubs::Node< ::stubs::Stmt>::Builder initThen();
  inline void adoptThen(::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>> disownThen();

  inline bool hasElse();
  inline  ::stubs::Node< ::stubs::Stmt>::Builder getElse();
  inline void setElse( ::stubs::Node< ::stubs::Stmt>::Reader value);
  inline  ::stubs::Node< ::stubs::Stmt>::Builder initElse();
  inline void adoptElse(::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>> disownElse();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stmt::If::Pipeline {
public:
  typedef If Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getCond();
  inline  ::stubs::Node< ::stubs::Stmt>::Pipeline getThen();
  inline  ::stubs::Node< ::stubs::Stmt>::Pipeline getElse();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Stmt::Compound::Reader {
public:
  typedef Compound Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasStmts() const;
  inline  ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Reader getStmts() const;

  inline bool hasRBrace() const;
  inline  ::stubs::Loc::Reader getRBrace() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stmt::Compound::Builder {
public:
  typedef Compound Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasStmts();
  inline  ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Builder getStmts();
  inline void setStmts( ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Builder initStmts(unsigned int size);
  inline void adoptStmts(::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>> disownStmts();

  inline bool hasRBrace();
  inline  ::stubs::Loc::Builder getRBrace();
  inline void setRBrace( ::stubs::Loc::Reader value);
  inline  ::stubs::Loc::Builder initRBrace();
  inline void adoptRBrace(::capnp::Orphan< ::stubs::Loc>&& value);
  inline ::capnp::Orphan< ::stubs::Loc> disownRBrace();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stmt::Compound::Pipeline {
public:
  typedef Compound Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Loc::Pipeline getRBrace();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Stmt::While::Reader {
public:
  typedef While Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCond() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getCond() const;

  inline bool hasBody() const;
  inline  ::stubs::Node< ::stubs::Stmt>::Reader getBody() const;

  inline bool hasSpec() const;
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader getSpec() const;

  inline bool hasWhileLoc() const;
  inline  ::stubs::Loc::Reader getWhileLoc() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stmt::While::Builder {
public:
  typedef While Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCond();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getCond();
  inline void setCond( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initCond();
  inline void adoptCond(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownCond();

  inline bool hasBody();
  inline  ::stubs::Node< ::stubs::Stmt>::Builder getBody();
  inline void setBody( ::stubs::Node< ::stubs::Stmt>::Reader value);
  inline  ::stubs::Node< ::stubs::Stmt>::Builder initBody();
  inline void adoptBody(::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>> disownBody();

  inline bool hasSpec();
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder getSpec();
  inline void setSpec( ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder initSpec(unsigned int size);
  inline void adoptSpec(::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>> disownSpec();

  inline bool hasWhileLoc();
  inline  ::stubs::Loc::Builder getWhileLoc();
  inline void setWhileLoc( ::stubs::Loc::Reader value);
  inline  ::stubs::Loc::Builder initWhileLoc();
  inline void adoptWhileLoc(::capnp::Orphan< ::stubs::Loc>&& value);
  inline ::capnp::Orphan< ::stubs::Loc> disownWhileLoc();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stmt::While::Pipeline {
public:
  typedef While Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getCond();
  inline  ::stubs::Node< ::stubs::Stmt>::Pipeline getBody();
  inline  ::stubs::Loc::Pipeline getWhileLoc();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Stmt::Case::Reader {
public:
  typedef Case Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLhs() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getLhs() const;

  inline bool hasStmt() const;
  inline  ::stubs::Node< ::stubs::Stmt>::Reader getStmt() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stmt::Case::Builder {
public:
  typedef Case Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLhs();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getLhs();
  inline void setLhs( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initLhs();
  inline void adoptLhs(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownLhs();

  inline bool hasStmt();
  inline  ::stubs::Node< ::stubs::Stmt>::Builder getStmt();
  inline void setStmt( ::stubs::Node< ::stubs::Stmt>::Reader value);
  inline  ::stubs::Node< ::stubs::Stmt>::Builder initStmt();
  inline void adoptStmt(::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>> disownStmt();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stmt::Case::Pipeline {
public:
  typedef Case Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getLhs();
  inline  ::stubs::Node< ::stubs::Stmt>::Pipeline getStmt();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Stmt::DefCase::Reader {
public:
  typedef DefCase Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasStmt() const;
  inline  ::stubs::Node< ::stubs::Stmt>::Reader getStmt() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stmt::DefCase::Builder {
public:
  typedef DefCase Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasStmt();
  inline  ::stubs::Node< ::stubs::Stmt>::Builder getStmt();
  inline void setStmt( ::stubs::Node< ::stubs::Stmt>::Reader value);
  inline  ::stubs::Node< ::stubs::Stmt>::Builder initStmt();
  inline void adoptStmt(::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>> disownStmt();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stmt::DefCase::Pipeline {
public:
  typedef DefCase Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Stmt>::Pipeline getStmt();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Stmt::Switch::Reader {
public:
  typedef Switch Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCond() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getCond() const;

  inline bool hasCases() const;
  inline  ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Reader getCases() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Stmt::Switch::Builder {
public:
  typedef Switch Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCond();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getCond();
  inline void setCond( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initCond();
  inline void adoptCond(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownCond();

  inline bool hasCases();
  inline  ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Builder getCases();
  inline void setCases( ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Builder initCases(unsigned int size);
  inline void adoptCases(::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>> disownCases();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Stmt::Switch::Pipeline {
public:
  typedef Switch Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getCond();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Reader {
public:
  typedef Decl Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnionNotInitialized() const;
  inline  ::capnp::Void getUnionNotInitialized() const;

  inline bool isAnn() const;
  inline bool hasAnn() const;
  inline  ::capnp::Text::Reader getAnn() const;

  inline bool isEmpty() const;
  inline  ::capnp::Void getEmpty() const;

  inline bool isVar() const;
  inline bool hasVar() const;
  inline  ::stubs::Decl::Var::Reader getVar() const;

  inline bool isFunction() const;
  inline bool hasFunction() const;
  inline  ::stubs::Decl::Function::Reader getFunction() const;

  inline bool isField() const;
  inline bool hasField() const;
  inline  ::stubs::Decl::Field::Reader getField() const;

  inline bool isRecord() const;
  inline bool hasRecord() const;
  inline  ::stubs::Decl::Record::Reader getRecord() const;

  inline bool isMethod() const;
  inline bool hasMethod() const;
  inline  ::stubs::Decl::Method::Reader getMethod() const;

  inline bool isAccessSpec() const;
  inline  ::capnp::Void getAccessSpec() const;

  inline bool isCtor() const;
  inline bool hasCtor() const;
  inline  ::stubs::Decl::Ctor::Reader getCtor() const;

  inline bool isDtor() const;
  inline bool hasDtor() const;
  inline  ::stubs::Decl::Dtor::Reader getDtor() const;

  inline bool isTypedef() const;
  inline bool hasTypedef() const;
  inline  ::stubs::Decl::Typedef::Reader getTypedef() const;

  inline bool isEnumDecl() const;
  inline bool hasEnumDecl() const;
  inline  ::stubs::Decl::Enum::Reader getEnumDecl() const;

  inline bool isNamespace() const;
  inline bool hasNamespace() const;
  inline  ::stubs::Decl::Namespace::Reader getNamespace() const;

  inline bool isFunctionTemplate() const;
  inline bool hasFunctionTemplate() const;
  inline  ::stubs::Decl::FunctionTemplate::Reader getFunctionTemplate() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Builder {
public:
  typedef Decl Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnionNotInitialized();
  inline  ::capnp::Void getUnionNotInitialized();
  inline void setUnionNotInitialized( ::capnp::Void value = ::capnp::VOID);

  inline bool isAnn();
  inline bool hasAnn();
  inline  ::capnp::Text::Builder getAnn();
  inline void setAnn( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initAnn(unsigned int size);
  inline void adoptAnn(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownAnn();

  inline bool isEmpty();
  inline  ::capnp::Void getEmpty();
  inline void setEmpty( ::capnp::Void value = ::capnp::VOID);

  inline bool isVar();
  inline bool hasVar();
  inline  ::stubs::Decl::Var::Builder getVar();
  inline void setVar( ::stubs::Decl::Var::Reader value);
  inline  ::stubs::Decl::Var::Builder initVar();
  inline void adoptVar(::capnp::Orphan< ::stubs::Decl::Var>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Var> disownVar();

  inline bool isFunction();
  inline bool hasFunction();
  inline  ::stubs::Decl::Function::Builder getFunction();
  inline void setFunction( ::stubs::Decl::Function::Reader value);
  inline  ::stubs::Decl::Function::Builder initFunction();
  inline void adoptFunction(::capnp::Orphan< ::stubs::Decl::Function>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Function> disownFunction();

  inline bool isField();
  inline bool hasField();
  inline  ::stubs::Decl::Field::Builder getField();
  inline void setField( ::stubs::Decl::Field::Reader value);
  inline  ::stubs::Decl::Field::Builder initField();
  inline void adoptField(::capnp::Orphan< ::stubs::Decl::Field>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Field> disownField();

  inline bool isRecord();
  inline bool hasRecord();
  inline  ::stubs::Decl::Record::Builder getRecord();
  inline void setRecord( ::stubs::Decl::Record::Reader value);
  inline  ::stubs::Decl::Record::Builder initRecord();
  inline void adoptRecord(::capnp::Orphan< ::stubs::Decl::Record>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Record> disownRecord();

  inline bool isMethod();
  inline bool hasMethod();
  inline  ::stubs::Decl::Method::Builder getMethod();
  inline void setMethod( ::stubs::Decl::Method::Reader value);
  inline  ::stubs::Decl::Method::Builder initMethod();
  inline void adoptMethod(::capnp::Orphan< ::stubs::Decl::Method>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Method> disownMethod();

  inline bool isAccessSpec();
  inline  ::capnp::Void getAccessSpec();
  inline void setAccessSpec( ::capnp::Void value = ::capnp::VOID);

  inline bool isCtor();
  inline bool hasCtor();
  inline  ::stubs::Decl::Ctor::Builder getCtor();
  inline void setCtor( ::stubs::Decl::Ctor::Reader value);
  inline  ::stubs::Decl::Ctor::Builder initCtor();
  inline void adoptCtor(::capnp::Orphan< ::stubs::Decl::Ctor>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Ctor> disownCtor();

  inline bool isDtor();
  inline bool hasDtor();
  inline  ::stubs::Decl::Dtor::Builder getDtor();
  inline void setDtor( ::stubs::Decl::Dtor::Reader value);
  inline  ::stubs::Decl::Dtor::Builder initDtor();
  inline void adoptDtor(::capnp::Orphan< ::stubs::Decl::Dtor>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Dtor> disownDtor();

  inline bool isTypedef();
  inline bool hasTypedef();
  inline  ::stubs::Decl::Typedef::Builder getTypedef();
  inline void setTypedef( ::stubs::Decl::Typedef::Reader value);
  inline  ::stubs::Decl::Typedef::Builder initTypedef();
  inline void adoptTypedef(::capnp::Orphan< ::stubs::Decl::Typedef>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Typedef> disownTypedef();

  inline bool isEnumDecl();
  inline bool hasEnumDecl();
  inline  ::stubs::Decl::Enum::Builder getEnumDecl();
  inline void setEnumDecl( ::stubs::Decl::Enum::Reader value);
  inline  ::stubs::Decl::Enum::Builder initEnumDecl();
  inline void adoptEnumDecl(::capnp::Orphan< ::stubs::Decl::Enum>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Enum> disownEnumDecl();

  inline bool isNamespace();
  inline bool hasNamespace();
  inline  ::stubs::Decl::Namespace::Builder getNamespace();
  inline void setNamespace( ::stubs::Decl::Namespace::Reader value);
  inline  ::stubs::Decl::Namespace::Builder initNamespace();
  inline void adoptNamespace(::capnp::Orphan< ::stubs::Decl::Namespace>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Namespace> disownNamespace();

  inline bool isFunctionTemplate();
  inline bool hasFunctionTemplate();
  inline  ::stubs::Decl::FunctionTemplate::Builder getFunctionTemplate();
  inline void setFunctionTemplate( ::stubs::Decl::FunctionTemplate::Reader value);
  inline  ::stubs::Decl::FunctionTemplate::Builder initFunctionTemplate();
  inline void adoptFunctionTemplate(::capnp::Orphan< ::stubs::Decl::FunctionTemplate>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::FunctionTemplate> disownFunctionTemplate();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Pipeline {
public:
  typedef Decl Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Var::Reader {
public:
  typedef Var Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasType() const;
  inline  ::stubs::Node< ::stubs::Type>::Reader getType() const;

  inline bool hasInit() const;
  inline  ::stubs::Decl::Var::VarInit::Reader getInit() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Var::Builder {
public:
  typedef Var Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasType();
  inline  ::stubs::Node< ::stubs::Type>::Builder getType();
  inline void setType( ::stubs::Node< ::stubs::Type>::Reader value);
  inline  ::stubs::Node< ::stubs::Type>::Builder initType();
  inline void adoptType(::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> disownType();

  inline bool hasInit();
  inline  ::stubs::Decl::Var::VarInit::Builder getInit();
  inline void setInit( ::stubs::Decl::Var::VarInit::Reader value);
  inline  ::stubs::Decl::Var::VarInit::Builder initInit();
  inline void adoptInit(::capnp::Orphan< ::stubs::Decl::Var::VarInit>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Var::VarInit> disownInit();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Var::Pipeline {
public:
  typedef Var Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Type>::Pipeline getType();
  inline  ::stubs::Decl::Var::VarInit::Pipeline getInit();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Var::VarInit::Reader {
public:
  typedef VarInit Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInit() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getInit() const;

  inline  ::stubs::Decl::Var::InitStyle getStyle() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Var::VarInit::Builder {
public:
  typedef VarInit Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInit();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getInit();
  inline void setInit( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initInit();
  inline void adoptInit(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownInit();

  inline  ::stubs::Decl::Var::InitStyle getStyle();
  inline void setStyle( ::stubs::Decl::Var::InitStyle value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Var::VarInit::Pipeline {
public:
  typedef VarInit Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getInit();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Function::Reader {
public:
  typedef Function Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasBody() const;
  inline  ::stubs::Node< ::stubs::Stmt>::Reader getBody() const;

  inline bool hasResult() const;
  inline  ::stubs::Node< ::stubs::Type>::Reader getResult() const;

  inline bool hasParams() const;
  inline  ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Reader getParams() const;

  inline bool hasContract() const;
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader getContract() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Function::Builder {
public:
  typedef Function Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasBody();
  inline  ::stubs::Node< ::stubs::Stmt>::Builder getBody();
  inline void setBody( ::stubs::Node< ::stubs::Stmt>::Reader value);
  inline  ::stubs::Node< ::stubs::Stmt>::Builder initBody();
  inline void adoptBody(::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>> disownBody();

  inline bool hasResult();
  inline  ::stubs::Node< ::stubs::Type>::Builder getResult();
  inline void setResult( ::stubs::Node< ::stubs::Type>::Reader value);
  inline  ::stubs::Node< ::stubs::Type>::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> disownResult();

  inline bool hasParams();
  inline  ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Builder getParams();
  inline void setParams( ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Builder initParams(unsigned int size);
  inline void adoptParams(::capnp::Orphan< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>> disownParams();

  inline bool hasContract();
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder getContract();
  inline void setContract( ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder initContract(unsigned int size);
  inline void adoptContract(::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>> disownContract();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Function::Pipeline {
public:
  typedef Function Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Stmt>::Pipeline getBody();
  inline  ::stubs::Node< ::stubs::Type>::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Field::Reader {
public:
  typedef Field Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasType() const;
  inline  ::stubs::Node< ::stubs::Type>::Reader getType() const;

  inline bool hasInit() const;
  inline  ::stubs::Decl::Field::FieldInit::Reader getInit() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Field::Builder {
public:
  typedef Field Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasType();
  inline  ::stubs::Node< ::stubs::Type>::Builder getType();
  inline void setType( ::stubs::Node< ::stubs::Type>::Reader value);
  inline  ::stubs::Node< ::stubs::Type>::Builder initType();
  inline void adoptType(::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> disownType();

  inline bool hasInit();
  inline  ::stubs::Decl::Field::FieldInit::Builder getInit();
  inline void setInit( ::stubs::Decl::Field::FieldInit::Reader value);
  inline  ::stubs::Decl::Field::FieldInit::Builder initInit();
  inline void adoptInit(::capnp::Orphan< ::stubs::Decl::Field::FieldInit>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Field::FieldInit> disownInit();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Field::Pipeline {
public:
  typedef Field Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Type>::Pipeline getType();
  inline  ::stubs::Decl::Field::FieldInit::Pipeline getInit();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Field::FieldInit::Reader {
public:
  typedef FieldInit Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInit() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getInit() const;

  inline  ::stubs::Decl::Field::InitStyle getStyle() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Field::FieldInit::Builder {
public:
  typedef FieldInit Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInit();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getInit();
  inline void setInit( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initInit();
  inline void adoptInit(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownInit();

  inline  ::stubs::Decl::Field::InitStyle getStyle();
  inline void setStyle( ::stubs::Decl::Field::InitStyle value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Field::FieldInit::Pipeline {
public:
  typedef FieldInit Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getInit();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Record::Reader {
public:
  typedef Record Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline  ::stubs::RecordKind getKind() const;

  inline bool hasBody() const;
  inline  ::stubs::Decl::Record::Body::Reader getBody() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Record::Builder {
public:
  typedef Record Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline  ::stubs::RecordKind getKind();
  inline void setKind( ::stubs::RecordKind value);

  inline bool hasBody();
  inline  ::stubs::Decl::Record::Body::Builder getBody();
  inline void setBody( ::stubs::Decl::Record::Body::Reader value);
  inline  ::stubs::Decl::Record::Body::Builder initBody();
  inline void adoptBody(::capnp::Orphan< ::stubs::Decl::Record::Body>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Record::Body> disownBody();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Record::Pipeline {
public:
  typedef Record Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Decl::Record::Body::Pipeline getBody();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Record::BaseSpec::Reader {
public:
  typedef BaseSpec Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool getVirtual() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Record::BaseSpec::Builder {
public:
  typedef BaseSpec Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool getVirtual();
  inline void setVirtual(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Record::BaseSpec::Pipeline {
public:
  typedef BaseSpec Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Record::Body::Reader {
public:
  typedef Body Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasDecls() const;
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader getDecls() const;

  inline bool hasBases() const;
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>::Reader getBases() const;

  inline bool getPolymorphic() const;

  inline bool hasNonOverriddenMethods() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getNonOverriddenMethods() const;

  inline bool getIsAbstract() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Record::Body::Builder {
public:
  typedef Body Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasDecls();
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder getDecls();
  inline void setDecls( ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder initDecls(unsigned int size);
  inline void adoptDecls(::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>> disownDecls();

  inline bool hasBases();
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>::Builder getBases();
  inline void setBases( ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>::Builder initBases(unsigned int size);
  inline void adoptBases(::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>> disownBases();

  inline bool getPolymorphic();
  inline void setPolymorphic(bool value);

  inline bool hasNonOverriddenMethods();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getNonOverriddenMethods();
  inline void setNonOverriddenMethods( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setNonOverriddenMethods(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initNonOverriddenMethods(unsigned int size);
  inline void adoptNonOverriddenMethods(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownNonOverriddenMethods();

  inline bool getIsAbstract();
  inline void setIsAbstract(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Record::Body::Pipeline {
public:
  typedef Body Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Method::Reader {
public:
  typedef Method Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getStatic() const;

  inline bool hasFunc() const;
  inline  ::stubs::Decl::Function::Reader getFunc() const;

  inline bool hasThis() const;
  inline  ::stubs::Type::Reader getThis() const;

  inline bool getImplicit() const;

  inline bool getVirtual() const;

  inline bool hasOverrides() const;
  inline  ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>::Reader getOverrides() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Method::Builder {
public:
  typedef Method Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getStatic();
  inline void setStatic(bool value);

  inline bool hasFunc();
  inline  ::stubs::Decl::Function::Builder getFunc();
  inline void setFunc( ::stubs::Decl::Function::Reader value);
  inline  ::stubs::Decl::Function::Builder initFunc();
  inline void adoptFunc(::capnp::Orphan< ::stubs::Decl::Function>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Function> disownFunc();

  inline bool hasThis();
  inline  ::stubs::Type::Builder getThis();
  inline void setThis( ::stubs::Type::Reader value);
  inline  ::stubs::Type::Builder initThis();
  inline void adoptThis(::capnp::Orphan< ::stubs::Type>&& value);
  inline ::capnp::Orphan< ::stubs::Type> disownThis();

  inline bool getImplicit();
  inline void setImplicit(bool value);

  inline bool getVirtual();
  inline void setVirtual(bool value);

  inline bool hasOverrides();
  inline  ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>::Builder getOverrides();
  inline void setOverrides( ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>::Builder initOverrides(unsigned int size);
  inline void adoptOverrides(::capnp::Orphan< ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>> disownOverrides();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Method::Pipeline {
public:
  typedef Method Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Decl::Function::Pipeline getFunc();
  inline  ::stubs::Type::Pipeline getThis();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Method::Override::Reader {
public:
  typedef Override Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasBase() const;
  inline  ::stubs::RecordRef::Reader getBase() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Method::Override::Builder {
public:
  typedef Override Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasBase();
  inline  ::stubs::RecordRef::Builder getBase();
  inline void setBase( ::stubs::RecordRef::Reader value);
  inline  ::stubs::RecordRef::Builder initBase();
  inline void adoptBase(::capnp::Orphan< ::stubs::RecordRef>&& value);
  inline ::capnp::Orphan< ::stubs::RecordRef> disownBase();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Method::Override::Pipeline {
public:
  typedef Override Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::RecordRef::Pipeline getBase();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Ctor::Reader {
public:
  typedef Ctor Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMethod() const;
  inline  ::stubs::Decl::Method::Reader getMethod() const;

  inline bool hasInitList() const;
  inline  ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>::Reader getInitList() const;

  inline bool hasParent() const;
  inline  ::stubs::RecordRef::Reader getParent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Ctor::Builder {
public:
  typedef Ctor Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMethod();
  inline  ::stubs::Decl::Method::Builder getMethod();
  inline void setMethod( ::stubs::Decl::Method::Reader value);
  inline  ::stubs::Decl::Method::Builder initMethod();
  inline void adoptMethod(::capnp::Orphan< ::stubs::Decl::Method>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Method> disownMethod();

  inline bool hasInitList();
  inline  ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>::Builder getInitList();
  inline void setInitList( ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>::Builder initInitList(unsigned int size);
  inline void adoptInitList(::capnp::Orphan< ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>> disownInitList();

  inline bool hasParent();
  inline  ::stubs::RecordRef::Builder getParent();
  inline void setParent( ::stubs::RecordRef::Reader value);
  inline  ::stubs::RecordRef::Builder initParent();
  inline void adoptParent(::capnp::Orphan< ::stubs::RecordRef>&& value);
  inline ::capnp::Orphan< ::stubs::RecordRef> disownParent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Ctor::Pipeline {
public:
  typedef Ctor Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Decl::Method::Pipeline getMethod();
  inline  ::stubs::RecordRef::Pipeline getParent();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Ctor::CtorInit::Reader {
public:
  typedef CtorInit Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasInit() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getInit() const;

  inline bool getIsWritten() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Ctor::CtorInit::Builder {
public:
  typedef CtorInit Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasInit();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getInit();
  inline void setInit( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initInit();
  inline void adoptInit(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownInit();

  inline bool getIsWritten();
  inline void setIsWritten(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Ctor::CtorInit::Pipeline {
public:
  typedef CtorInit Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getInit();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Dtor::Reader {
public:
  typedef Dtor Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMethod() const;
  inline  ::stubs::Decl::Method::Reader getMethod() const;

  inline bool hasParent() const;
  inline  ::stubs::RecordRef::Reader getParent() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Dtor::Builder {
public:
  typedef Dtor Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMethod();
  inline  ::stubs::Decl::Method::Builder getMethod();
  inline void setMethod( ::stubs::Decl::Method::Reader value);
  inline  ::stubs::Decl::Method::Builder initMethod();
  inline void adoptMethod(::capnp::Orphan< ::stubs::Decl::Method>&& value);
  inline ::capnp::Orphan< ::stubs::Decl::Method> disownMethod();

  inline bool hasParent();
  inline  ::stubs::RecordRef::Builder getParent();
  inline void setParent( ::stubs::RecordRef::Reader value);
  inline  ::stubs::RecordRef::Builder initParent();
  inline void adoptParent(::capnp::Orphan< ::stubs::RecordRef>&& value);
  inline ::capnp::Orphan< ::stubs::RecordRef> disownParent();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Dtor::Pipeline {
public:
  typedef Dtor Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Decl::Method::Pipeline getMethod();
  inline  ::stubs::RecordRef::Pipeline getParent();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Typedef::Reader {
public:
  typedef Typedef Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasType() const;
  inline  ::stubs::Node< ::stubs::Type>::Reader getType() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Typedef::Builder {
public:
  typedef Typedef Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasType();
  inline  ::stubs::Node< ::stubs::Type>::Builder getType();
  inline void setType( ::stubs::Node< ::stubs::Type>::Reader value);
  inline  ::stubs::Node< ::stubs::Type>::Builder initType();
  inline void adoptType(::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> disownType();

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Typedef::Pipeline {
public:
  typedef Typedef Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Type>::Pipeline getType();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Enum::Reader {
public:
  typedef Enum Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasFields() const;
  inline  ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>::Reader getFields() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Enum::Builder {
public:
  typedef Enum Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasFields();
  inline  ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>::Builder getFields();
  inline void setFields( ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>::Builder initFields(unsigned int size);
  inline void adoptFields(::capnp::Orphan< ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>> disownFields();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Enum::Pipeline {
public:
  typedef Enum Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Enum::EnumField::Reader {
public:
  typedef EnumField Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasExpr() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getExpr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Enum::EnumField::Builder {
public:
  typedef EnumField Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasExpr();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getExpr();
  inline void setExpr( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initExpr();
  inline void adoptExpr(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownExpr();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Enum::EnumField::Pipeline {
public:
  typedef EnumField Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getExpr();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::Namespace::Reader {
public:
  typedef Namespace Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasDecls() const;
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader getDecls() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::Namespace::Builder {
public:
  typedef Namespace Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasDecls();
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder getDecls();
  inline void setDecls( ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder initDecls(unsigned int size);
  inline void adoptDecls(::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>> disownDecls();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::Namespace::Pipeline {
public:
  typedef Namespace Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Decl::FunctionTemplate::Reader {
public:
  typedef FunctionTemplate Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasSpecs() const;
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>::Reader getSpecs() const;

  inline bool hasContract() const;
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader getContract() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Decl::FunctionTemplate::Builder {
public:
  typedef FunctionTemplate Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasSpecs();
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>::Builder getSpecs();
  inline void setSpecs( ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>::Builder initSpecs(unsigned int size);
  inline void adoptSpecs(::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>> disownSpecs();

  inline bool hasContract();
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder getContract();
  inline void setContract( ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder initContract(unsigned int size);
  inline void adoptContract(::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>> disownContract();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Decl::FunctionTemplate::Pipeline {
public:
  typedef FunctionTemplate Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::Reader {
public:
  typedef Expr Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnionNotInitialized() const;
  inline  ::capnp::Void getUnionNotInitialized() const;

  inline bool isUnaryOp() const;
  inline bool hasUnaryOp() const;
  inline  ::stubs::Expr::UnaryOp::Reader getUnaryOp() const;

  inline bool isBinaryOp() const;
  inline bool hasBinaryOp() const;
  inline  ::stubs::Expr::BinaryOp::Reader getBinaryOp() const;

  inline bool isBoolLit() const;
  inline bool getBoolLit() const;

  inline bool isIntLit() const;
  inline bool hasIntLit() const;
  inline  ::stubs::Expr::IntLit::Reader getIntLit() const;

  inline bool isStringLit() const;
  inline bool hasStringLit() const;
  inline  ::capnp::Text::Reader getStringLit() const;

  inline bool isCall() const;
  inline bool hasCall() const;
  inline  ::stubs::Expr::Call::Reader getCall() const;

  inline bool isDeclRef() const;
  inline bool hasDeclRef() const;
  inline  ::capnp::Text::Reader getDeclRef() const;

  inline bool isMember() const;
  inline bool hasMember() const;
  inline  ::stubs::Expr::Member::Reader getMember() const;

  inline bool isThis() const;
  inline  ::capnp::Void getThis() const;

  inline bool isMemberCall() const;
  inline bool hasMemberCall() const;
  inline  ::stubs::Expr::MemberCall::Reader getMemberCall() const;

  inline bool isNew() const;
  inline bool hasNew() const;
  inline  ::stubs::Expr::New::Reader getNew() const;

  inline bool isConstruct() const;
  inline bool hasConstruct() const;
  inline  ::stubs::Expr::Construct::Reader getConstruct() const;

  inline bool isNullPtrLit() const;
  inline  ::capnp::Void getNullPtrLit() const;

  inline bool isDelete() const;
  inline bool hasDelete() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getDelete() const;

  inline bool isTruncating() const;
  inline bool hasTruncating() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getTruncating() const;

  inline bool isLValueToRValue() const;
  inline bool hasLValueToRValue() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getLValueToRValue() const;

  inline bool isDerivedToBase() const;
  inline bool hasDerivedToBase() const;
  inline  ::stubs::Expr::StructToStruct::Reader getDerivedToBase() const;

  inline bool isBaseToDerived() const;
  inline bool hasBaseToDerived() const;
  inline  ::stubs::Expr::StructToStruct::Reader getBaseToDerived() const;

  inline bool isOperatorCall() const;
  inline bool hasOperatorCall() const;
  inline  ::stubs::Expr::Call::Reader getOperatorCall() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::Builder {
public:
  typedef Expr Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnionNotInitialized();
  inline  ::capnp::Void getUnionNotInitialized();
  inline void setUnionNotInitialized( ::capnp::Void value = ::capnp::VOID);

  inline bool isUnaryOp();
  inline bool hasUnaryOp();
  inline  ::stubs::Expr::UnaryOp::Builder getUnaryOp();
  inline void setUnaryOp( ::stubs::Expr::UnaryOp::Reader value);
  inline  ::stubs::Expr::UnaryOp::Builder initUnaryOp();
  inline void adoptUnaryOp(::capnp::Orphan< ::stubs::Expr::UnaryOp>&& value);
  inline ::capnp::Orphan< ::stubs::Expr::UnaryOp> disownUnaryOp();

  inline bool isBinaryOp();
  inline bool hasBinaryOp();
  inline  ::stubs::Expr::BinaryOp::Builder getBinaryOp();
  inline void setBinaryOp( ::stubs::Expr::BinaryOp::Reader value);
  inline  ::stubs::Expr::BinaryOp::Builder initBinaryOp();
  inline void adoptBinaryOp(::capnp::Orphan< ::stubs::Expr::BinaryOp>&& value);
  inline ::capnp::Orphan< ::stubs::Expr::BinaryOp> disownBinaryOp();

  inline bool isBoolLit();
  inline bool getBoolLit();
  inline void setBoolLit(bool value);

  inline bool isIntLit();
  inline bool hasIntLit();
  inline  ::stubs::Expr::IntLit::Builder getIntLit();
  inline void setIntLit( ::stubs::Expr::IntLit::Reader value);
  inline  ::stubs::Expr::IntLit::Builder initIntLit();
  inline void adoptIntLit(::capnp::Orphan< ::stubs::Expr::IntLit>&& value);
  inline ::capnp::Orphan< ::stubs::Expr::IntLit> disownIntLit();

  inline bool isStringLit();
  inline bool hasStringLit();
  inline  ::capnp::Text::Builder getStringLit();
  inline void setStringLit( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initStringLit(unsigned int size);
  inline void adoptStringLit(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownStringLit();

  inline bool isCall();
  inline bool hasCall();
  inline  ::stubs::Expr::Call::Builder getCall();
  inline void setCall( ::stubs::Expr::Call::Reader value);
  inline  ::stubs::Expr::Call::Builder initCall();
  inline void adoptCall(::capnp::Orphan< ::stubs::Expr::Call>&& value);
  inline ::capnp::Orphan< ::stubs::Expr::Call> disownCall();

  inline bool isDeclRef();
  inline bool hasDeclRef();
  inline  ::capnp::Text::Builder getDeclRef();
  inline void setDeclRef( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initDeclRef(unsigned int size);
  inline void adoptDeclRef(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownDeclRef();

  inline bool isMember();
  inline bool hasMember();
  inline  ::stubs::Expr::Member::Builder getMember();
  inline void setMember( ::stubs::Expr::Member::Reader value);
  inline  ::stubs::Expr::Member::Builder initMember();
  inline void adoptMember(::capnp::Orphan< ::stubs::Expr::Member>&& value);
  inline ::capnp::Orphan< ::stubs::Expr::Member> disownMember();

  inline bool isThis();
  inline  ::capnp::Void getThis();
  inline void setThis( ::capnp::Void value = ::capnp::VOID);

  inline bool isMemberCall();
  inline bool hasMemberCall();
  inline  ::stubs::Expr::MemberCall::Builder getMemberCall();
  inline void setMemberCall( ::stubs::Expr::MemberCall::Reader value);
  inline  ::stubs::Expr::MemberCall::Builder initMemberCall();
  inline void adoptMemberCall(::capnp::Orphan< ::stubs::Expr::MemberCall>&& value);
  inline ::capnp::Orphan< ::stubs::Expr::MemberCall> disownMemberCall();

  inline bool isNew();
  inline bool hasNew();
  inline  ::stubs::Expr::New::Builder getNew();
  inline void setNew( ::stubs::Expr::New::Reader value);
  inline  ::stubs::Expr::New::Builder initNew();
  inline void adoptNew(::capnp::Orphan< ::stubs::Expr::New>&& value);
  inline ::capnp::Orphan< ::stubs::Expr::New> disownNew();

  inline bool isConstruct();
  inline bool hasConstruct();
  inline  ::stubs::Expr::Construct::Builder getConstruct();
  inline void setConstruct( ::stubs::Expr::Construct::Reader value);
  inline  ::stubs::Expr::Construct::Builder initConstruct();
  inline void adoptConstruct(::capnp::Orphan< ::stubs::Expr::Construct>&& value);
  inline ::capnp::Orphan< ::stubs::Expr::Construct> disownConstruct();

  inline bool isNullPtrLit();
  inline  ::capnp::Void getNullPtrLit();
  inline void setNullPtrLit( ::capnp::Void value = ::capnp::VOID);

  inline bool isDelete();
  inline bool hasDelete();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getDelete();
  inline void setDelete( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initDelete();
  inline void adoptDelete(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownDelete();

  inline bool isTruncating();
  inline bool hasTruncating();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getTruncating();
  inline void setTruncating( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initTruncating();
  inline void adoptTruncating(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownTruncating();

  inline bool isLValueToRValue();
  inline bool hasLValueToRValue();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getLValueToRValue();
  inline void setLValueToRValue( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initLValueToRValue();
  inline void adoptLValueToRValue(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownLValueToRValue();

  inline bool isDerivedToBase();
  inline bool hasDerivedToBase();
  inline  ::stubs::Expr::StructToStruct::Builder getDerivedToBase();
  inline void setDerivedToBase( ::stubs::Expr::StructToStruct::Reader value);
  inline  ::stubs::Expr::StructToStruct::Builder initDerivedToBase();
  inline void adoptDerivedToBase(::capnp::Orphan< ::stubs::Expr::StructToStruct>&& value);
  inline ::capnp::Orphan< ::stubs::Expr::StructToStruct> disownDerivedToBase();

  inline bool isBaseToDerived();
  inline bool hasBaseToDerived();
  inline  ::stubs::Expr::StructToStruct::Builder getBaseToDerived();
  inline void setBaseToDerived( ::stubs::Expr::StructToStruct::Reader value);
  inline  ::stubs::Expr::StructToStruct::Builder initBaseToDerived();
  inline void adoptBaseToDerived(::capnp::Orphan< ::stubs::Expr::StructToStruct>&& value);
  inline ::capnp::Orphan< ::stubs::Expr::StructToStruct> disownBaseToDerived();

  inline bool isOperatorCall();
  inline bool hasOperatorCall();
  inline  ::stubs::Expr::Call::Builder getOperatorCall();
  inline void setOperatorCall( ::stubs::Expr::Call::Reader value);
  inline  ::stubs::Expr::Call::Builder initOperatorCall();
  inline void adoptOperatorCall(::capnp::Orphan< ::stubs::Expr::Call>&& value);
  inline ::capnp::Orphan< ::stubs::Expr::Call> disownOperatorCall();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::Pipeline {
public:
  typedef Expr Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::UnaryOp::Reader {
public:
  typedef UnaryOp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasOperand() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getOperand() const;

  inline  ::stubs::UnaryOpKind getKind() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::UnaryOp::Builder {
public:
  typedef UnaryOp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasOperand();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getOperand();
  inline void setOperand( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initOperand();
  inline void adoptOperand(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownOperand();

  inline  ::stubs::UnaryOpKind getKind();
  inline void setKind( ::stubs::UnaryOpKind value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::UnaryOp::Pipeline {
public:
  typedef UnaryOp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getOperand();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::BinaryOp::Reader {
public:
  typedef BinaryOp Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLhs() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getLhs() const;

  inline bool hasRhs() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getRhs() const;

  inline  ::stubs::BinaryOpKind getKind() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::BinaryOp::Builder {
public:
  typedef BinaryOp Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLhs();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getLhs();
  inline void setLhs( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initLhs();
  inline void adoptLhs(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownLhs();

  inline bool hasRhs();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getRhs();
  inline void setRhs( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initRhs();
  inline void adoptRhs(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownRhs();

  inline  ::stubs::BinaryOpKind getKind();
  inline void setKind( ::stubs::BinaryOpKind value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::BinaryOp::Pipeline {
public:
  typedef BinaryOp Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getLhs();
  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getRhs();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::IntLit::Reader {
public:
  typedef IntLit Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasValue() const;
  inline  ::capnp::Text::Reader getValue() const;

  inline bool getUSuffix() const;

  inline  ::stubs::SufKind getLSuffix() const;

  inline  ::stubs::NbBase getBase() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::IntLit::Builder {
public:
  typedef IntLit Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasValue();
  inline  ::capnp::Text::Builder getValue();
  inline void setValue( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownValue();

  inline bool getUSuffix();
  inline void setUSuffix(bool value);

  inline  ::stubs::SufKind getLSuffix();
  inline void setLSuffix( ::stubs::SufKind value);

  inline  ::stubs::NbBase getBase();
  inline void setBase( ::stubs::NbBase value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::IntLit::Pipeline {
public:
  typedef IntLit Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::Call::Reader {
public:
  typedef Call Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasArgs() const;
  inline  ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Reader getArgs() const;

  inline bool hasCallee() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getCallee() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::Call::Builder {
public:
  typedef Call Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasArgs();
  inline  ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Builder getArgs();
  inline void setArgs( ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Builder initArgs(unsigned int size);
  inline void adoptArgs(::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>> disownArgs();

  inline bool hasCallee();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getCallee();
  inline void setCallee( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initCallee();
  inline void adoptCallee(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownCallee();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::Call::Pipeline {
public:
  typedef Call Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getCallee();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::MemberCall::Reader {
public:
  typedef MemberCall Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasImplicitArg() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getImplicitArg() const;

  inline bool getArrow() const;

  inline bool hasCall() const;
  inline  ::stubs::Expr::Call::Reader getCall() const;

  inline bool getTargetHasQualifier() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::MemberCall::Builder {
public:
  typedef MemberCall Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasImplicitArg();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getImplicitArg();
  inline void setImplicitArg( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initImplicitArg();
  inline void adoptImplicitArg(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownImplicitArg();

  inline bool getArrow();
  inline void setArrow(bool value);

  inline bool hasCall();
  inline  ::stubs::Expr::Call::Builder getCall();
  inline void setCall( ::stubs::Expr::Call::Reader value);
  inline  ::stubs::Expr::Call::Builder initCall();
  inline void adoptCall(::capnp::Orphan< ::stubs::Expr::Call>&& value);
  inline ::capnp::Orphan< ::stubs::Expr::Call> disownCall();

  inline bool getTargetHasQualifier();
  inline void setTargetHasQualifier(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::MemberCall::Pipeline {
public:
  typedef MemberCall Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getImplicitArg();
  inline  ::stubs::Expr::Call::Pipeline getCall();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::Member::Reader {
public:
  typedef Member Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBase() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getBase() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool getArrow() const;

  inline bool getBaseIsPointer() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::Member::Builder {
public:
  typedef Member Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBase();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getBase();
  inline void setBase( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initBase();
  inline void adoptBase(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownBase();

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool getArrow();
  inline void setArrow(bool value);

  inline bool getBaseIsPointer();
  inline void setBaseIsPointer(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::Member::Pipeline {
public:
  typedef Member Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getBase();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::New::Reader {
public:
  typedef New Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasType() const;
  inline  ::stubs::Type::Reader getType() const;

  inline bool hasExpr() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getExpr() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::New::Builder {
public:
  typedef New Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasType();
  inline  ::stubs::Type::Builder getType();
  inline void setType( ::stubs::Type::Reader value);
  inline  ::stubs::Type::Builder initType();
  inline void adoptType(::capnp::Orphan< ::stubs::Type>&& value);
  inline ::capnp::Orphan< ::stubs::Type> disownType();

  inline bool hasExpr();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getExpr();
  inline void setExpr( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initExpr();
  inline void adoptExpr(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownExpr();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::New::Pipeline {
public:
  typedef New Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Type::Pipeline getType();
  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getExpr();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::Construct::Reader {
public:
  typedef Construct Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasArgs() const;
  inline  ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Reader getArgs() const;

  inline bool hasType() const;
  inline  ::stubs::Type::Reader getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::Construct::Builder {
public:
  typedef Construct Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasArgs();
  inline  ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Builder getArgs();
  inline void setArgs( ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Builder initArgs(unsigned int size);
  inline void adoptArgs(::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>> disownArgs();

  inline bool hasType();
  inline  ::stubs::Type::Builder getType();
  inline void setType( ::stubs::Type::Reader value);
  inline  ::stubs::Type::Builder initType();
  inline void adoptType(::capnp::Orphan< ::stubs::Type>&& value);
  inline ::capnp::Orphan< ::stubs::Type> disownType();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::Construct::Pipeline {
public:
  typedef Construct Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Type::Pipeline getType();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Expr::StructToStruct::Reader {
public:
  typedef StructToStruct Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasExpr() const;
  inline  ::stubs::Node< ::stubs::Expr>::Reader getExpr() const;

  inline bool hasType() const;
  inline  ::stubs::Type::Reader getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Expr::StructToStruct::Builder {
public:
  typedef StructToStruct Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasExpr();
  inline  ::stubs::Node< ::stubs::Expr>::Builder getExpr();
  inline void setExpr( ::stubs::Node< ::stubs::Expr>::Reader value);
  inline  ::stubs::Node< ::stubs::Expr>::Builder initExpr();
  inline void adoptExpr(::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value);
  inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> disownExpr();

  inline bool hasType();
  inline  ::stubs::Type::Builder getType();
  inline void setType( ::stubs::Type::Reader value);
  inline  ::stubs::Type::Builder initType();
  inline void adoptType(::capnp::Orphan< ::stubs::Type>&& value);
  inline ::capnp::Orphan< ::stubs::Type> disownType();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Expr::StructToStruct::Pipeline {
public:
  typedef StructToStruct Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Node< ::stubs::Expr>::Pipeline getExpr();
  inline  ::stubs::Type::Pipeline getType();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Include::Reader {
public:
  typedef Include Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUnionNotInitialized() const;
  inline  ::capnp::Void getUnionNotInitialized() const;

  inline bool isRealInclude() const;
  inline bool hasRealInclude() const;
  inline  ::stubs::Include::RealInclude::Reader getRealInclude() const;

  inline bool isGhostInclude() const;
  inline bool hasGhostInclude() const;
  inline  ::stubs::Clause::Reader getGhostInclude() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Include::Builder {
public:
  typedef Include Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUnionNotInitialized();
  inline  ::capnp::Void getUnionNotInitialized();
  inline void setUnionNotInitialized( ::capnp::Void value = ::capnp::VOID);

  inline bool isRealInclude();
  inline bool hasRealInclude();
  inline  ::stubs::Include::RealInclude::Builder getRealInclude();
  inline void setRealInclude( ::stubs::Include::RealInclude::Reader value);
  inline  ::stubs::Include::RealInclude::Builder initRealInclude();
  inline void adoptRealInclude(::capnp::Orphan< ::stubs::Include::RealInclude>&& value);
  inline ::capnp::Orphan< ::stubs::Include::RealInclude> disownRealInclude();

  inline bool isGhostInclude();
  inline bool hasGhostInclude();
  inline  ::stubs::Clause::Builder getGhostInclude();
  inline void setGhostInclude( ::stubs::Clause::Reader value);
  inline  ::stubs::Clause::Builder initGhostInclude();
  inline void adoptGhostInclude(::capnp::Orphan< ::stubs::Clause>&& value);
  inline ::capnp::Orphan< ::stubs::Clause> disownGhostInclude();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Include::Pipeline {
public:
  typedef Include Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Include::RealInclude::Reader {
public:
  typedef RealInclude Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLoc() const;
  inline  ::stubs::Loc::Reader getLoc() const;

  inline bool hasFileName() const;
  inline  ::capnp::Text::Reader getFileName() const;

  inline  ::uint16_t getFd() const;

  inline bool hasIncludes() const;
  inline  ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Reader getIncludes() const;

  inline bool getIsAngled() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Include::RealInclude::Builder {
public:
  typedef RealInclude Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLoc();
  inline  ::stubs::Loc::Builder getLoc();
  inline void setLoc( ::stubs::Loc::Reader value);
  inline  ::stubs::Loc::Builder initLoc();
  inline void adoptLoc(::capnp::Orphan< ::stubs::Loc>&& value);
  inline ::capnp::Orphan< ::stubs::Loc> disownLoc();

  inline bool hasFileName();
  inline  ::capnp::Text::Builder getFileName();
  inline void setFileName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFileName(unsigned int size);
  inline void adoptFileName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFileName();

  inline  ::uint16_t getFd();
  inline void setFd( ::uint16_t value);

  inline bool hasIncludes();
  inline  ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Builder getIncludes();
  inline void setIncludes( ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Builder initIncludes(unsigned int size);
  inline void adoptIncludes(::capnp::Orphan< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>> disownIncludes();

  inline bool getIsAngled();
  inline void setIsAngled(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Include::RealInclude::Pipeline {
public:
  typedef RealInclude Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Loc::Pipeline getLoc();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class File::Reader {
public:
  typedef File Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getFd() const;

  inline bool hasPath() const;
  inline  ::capnp::Text::Reader getPath() const;

  inline bool hasDecls() const;
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader getDecls() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class File::Builder {
public:
  typedef File Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getFd();
  inline void setFd( ::uint16_t value);

  inline bool hasPath();
  inline  ::capnp::Text::Builder getPath();
  inline void setPath( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPath(unsigned int size);
  inline void adoptPath(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPath();

  inline bool hasDecls();
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder getDecls();
  inline void setDecls( ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder initDecls(unsigned int size);
  inline void adoptDecls(::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>> disownDecls();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class File::Pipeline {
public:
  typedef File Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TU::Reader {
public:
  typedef TU Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getMainFd() const;

  inline bool hasIncludes() const;
  inline  ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Reader getIncludes() const;

  inline bool hasFiles() const;
  inline  ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>::Reader getFiles() const;

  inline bool hasFailDirectives() const;
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader getFailDirectives() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TU::Builder {
public:
  typedef TU Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getMainFd();
  inline void setMainFd( ::uint16_t value);

  inline bool hasIncludes();
  inline  ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Builder getIncludes();
  inline void setIncludes( ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Builder initIncludes(unsigned int size);
  inline void adoptIncludes(::capnp::Orphan< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>> disownIncludes();

  inline bool hasFiles();
  inline  ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>::Builder getFiles();
  inline void setFiles( ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>::Builder initFiles(unsigned int size);
  inline void adoptFiles(::capnp::Orphan< ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>> disownFiles();

  inline bool hasFailDirectives();
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder getFailDirectives();
  inline void setFailDirectives( ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder initFailDirectives(unsigned int size);
  inline void adoptFailDirectives(::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>> disownFailDirectives();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TU::Pipeline {
public:
  typedef TU Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Err::Reader {
public:
  typedef Err Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLoc() const;
  inline  ::stubs::Loc::Reader getLoc() const;

  inline bool hasReason() const;
  inline  ::capnp::Text::Reader getReason() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Err::Builder {
public:
  typedef Err Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLoc();
  inline  ::stubs::Loc::Builder getLoc();
  inline void setLoc( ::stubs::Loc::Reader value);
  inline  ::stubs::Loc::Builder initLoc();
  inline void adoptLoc(::capnp::Orphan< ::stubs::Loc>&& value);
  inline ::capnp::Orphan< ::stubs::Loc> disownLoc();

  inline bool hasReason();
  inline  ::capnp::Text::Builder getReason();
  inline void setReason( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initReason(unsigned int size);
  inline void adoptReason(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownReason();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Err::Pipeline {
public:
  typedef Err Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::Loc::Pipeline getLoc();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class VfError::Reader {
public:
  typedef VfError Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTu() const;
  inline  ::stubs::TU::Reader getTu() const;

  inline bool hasErrors() const;
  inline  ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>::Reader getErrors() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class VfError::Builder {
public:
  typedef VfError Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTu();
  inline  ::stubs::TU::Builder getTu();
  inline void setTu( ::stubs::TU::Reader value);
  inline  ::stubs::TU::Builder initTu();
  inline void adoptTu(::capnp::Orphan< ::stubs::TU>&& value);
  inline ::capnp::Orphan< ::stubs::TU> disownTu();

  inline bool hasErrors();
  inline  ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>::Builder getErrors();
  inline void setErrors( ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>::Builder initErrors(unsigned int size);
  inline void adoptErrors(::capnp::Orphan< ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>> disownErrors();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class VfError::Pipeline {
public:
  typedef VfError Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::stubs::TU::Pipeline getTu();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SerResult::Reader {
public:
  typedef SerResult Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isOk() const;
  inline bool hasOk() const;
  inline  ::stubs::TU::Reader getOk() const;

  inline bool isClangError() const;
  inline  ::capnp::Void getClangError() const;

  inline bool isVfError() const;
  inline bool hasVfError() const;
  inline  ::stubs::VfError::Reader getVfError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SerResult::Builder {
public:
  typedef SerResult Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isOk();
  inline bool hasOk();
  inline  ::stubs::TU::Builder getOk();
  inline void setOk( ::stubs::TU::Reader value);
  inline  ::stubs::TU::Builder initOk();
  inline void adoptOk(::capnp::Orphan< ::stubs::TU>&& value);
  inline ::capnp::Orphan< ::stubs::TU> disownOk();

  inline bool isClangError();
  inline  ::capnp::Void getClangError();
  inline void setClangError( ::capnp::Void value = ::capnp::VOID);

  inline bool isVfError();
  inline bool hasVfError();
  inline  ::stubs::VfError::Builder getVfError();
  inline void setVfError( ::stubs::VfError::Reader value);
  inline  ::stubs::VfError::Builder initVfError();
  inline void adoptVfError(::capnp::Orphan< ::stubs::VfError>&& value);
  inline ::capnp::Orphan< ::stubs::VfError> disownVfError();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SerResult::Pipeline {
public:
  typedef SerResult Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool Loc::Reader::hasStart() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Loc::Builder::hasStart() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Loc::SrcPos::Reader Loc::Reader::getStart() const {
  return ::capnp::_::PointerHelpers< ::stubs::Loc::SrcPos>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Loc::SrcPos::Builder Loc::Builder::getStart() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc::SrcPos>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Loc::SrcPos::Pipeline Loc::Pipeline::getStart() {
  return  ::stubs::Loc::SrcPos::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Loc::Builder::setStart( ::stubs::Loc::SrcPos::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc::SrcPos>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Loc::SrcPos::Builder Loc::Builder::initStart() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc::SrcPos>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Loc::Builder::adoptStart(
    ::capnp::Orphan< ::stubs::Loc::SrcPos>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc::SrcPos>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Loc::SrcPos> Loc::Builder::disownStart() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc::SrcPos>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Loc::Reader::hasEnd() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Loc::Builder::hasEnd() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Loc::SrcPos::Reader Loc::Reader::getEnd() const {
  return ::capnp::_::PointerHelpers< ::stubs::Loc::SrcPos>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Loc::SrcPos::Builder Loc::Builder::getEnd() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc::SrcPos>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Loc::SrcPos::Pipeline Loc::Pipeline::getEnd() {
  return  ::stubs::Loc::SrcPos::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Loc::Builder::setEnd( ::stubs::Loc::SrcPos::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc::SrcPos>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Loc::SrcPos::Builder Loc::Builder::initEnd() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc::SrcPos>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Loc::Builder::adoptEnd(
    ::capnp::Orphan< ::stubs::Loc::SrcPos>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc::SrcPos>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Loc::SrcPos> Loc::Builder::disownEnd() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc::SrcPos>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint16_t Loc::SrcPos::Reader::getL() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Loc::SrcPos::Builder::getL() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Loc::SrcPos::Builder::setL( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Loc::SrcPos::Reader::getC() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Loc::SrcPos::Builder::getC() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Loc::SrcPos::Builder::setC( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Loc::SrcPos::Reader::getFd() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Loc::SrcPos::Builder::getFd() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Loc::SrcPos::Builder::setFd( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

template <typename Base>
inline bool Node<Base>::Reader::hasLoc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Base>
inline bool Node<Base>::Builder::hasLoc() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Base>
inline  ::stubs::Loc::Reader Node<Base>::Reader::getLoc() const {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Base>
inline  ::stubs::Loc::Builder Node<Base>::Builder::getLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Base>
inline  ::stubs::Loc::Pipeline Node<Base>::Pipeline::getLoc() {
  return  ::stubs::Loc::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Base>
inline void Node<Base>::Builder::setLoc( ::stubs::Loc::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Base>
inline  ::stubs::Loc::Builder Node<Base>::Builder::initLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Base>
inline void Node<Base>::Builder::adoptLoc(
    ::capnp::Orphan< ::stubs::Loc>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Base>
inline ::capnp::Orphan< ::stubs::Loc> Node<Base>::Builder::disownLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Base>
inline bool Node<Base>::Reader::hasDesc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Base>
inline bool Node<Base>::Builder::hasDesc() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Base>
inline  ::capnp::ReaderFor<Base> Node<Base>::Reader::getDesc() const {
  return ::capnp::_::PointerHelpers<Base>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Base>
inline  ::capnp::BuilderFor<Base> Node<Base>::Builder::getDesc() {
  return ::capnp::_::PointerHelpers<Base>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Base>
inline  ::capnp::PipelineFor<Base> Node<Base>::Pipeline::getDesc() {
  return  ::capnp::PipelineFor<Base>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename Base>
inline void Node<Base>::Builder::setDesc( ::capnp::ReaderFor<Base> value) {
  ::capnp::_::PointerHelpers<Base>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Base>
inline  ::capnp::BuilderFor<Base> Node<Base>::Builder::initDesc() {
  return ::capnp::_::PointerHelpers<Base>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Base>
inline  ::capnp::BuilderFor<Base> Node<Base>::Builder::initDesc(unsigned int size) {
  return ::capnp::_::PointerHelpers<Base>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename Base>
inline void Node<Base>::Builder::adoptDesc(
    ::capnp::Orphan<Base>&& value) {
  ::capnp::_::PointerHelpers<Base>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Base>
inline ::capnp::Orphan<Base> Node<Base>::Builder::disownDesc() {
  return ::capnp::_::PointerHelpers<Base>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// Node<Base>
template <typename Base>
constexpr uint16_t Node<Base>::_capnpPrivate::dataWordSize;
template <typename Base>
constexpr uint16_t Node<Base>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename Base>
constexpr ::capnp::Kind Node<Base>::_capnpPrivate::kind;
template <typename Base>
constexpr ::capnp::_::RawSchema const* Node<Base>::_capnpPrivate::schema;
template <typename Base>
const ::capnp::_::RawBrandedSchema::Scope Node<Base>::_capnpPrivate::brandScopes[] = {
  { 0xe2a8b78aa50d684a, brandBindings + 0, 1, false},
};
template <typename Base>
const ::capnp::_::RawBrandedSchema::Binding Node<Base>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Base>(),
};
template <typename Base>
const ::capnp::_::RawBrandedSchema Node<Base>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e2a8b78aa50d684a, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

inline bool Clause::Reader::hasLoc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Clause::Builder::hasLoc() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Loc::Reader Clause::Reader::getLoc() const {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Loc::Builder Clause::Builder::getLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Loc::Pipeline Clause::Pipeline::getLoc() {
  return  ::stubs::Loc::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Clause::Builder::setLoc( ::stubs::Loc::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Loc::Builder Clause::Builder::initLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Clause::Builder::adoptLoc(
    ::capnp::Orphan< ::stubs::Loc>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Loc> Clause::Builder::disownLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Clause::Reader::hasText() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Clause::Builder::hasText() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Clause::Reader::getText() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Clause::Builder::getText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Clause::Builder::setText( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Clause::Builder::initText(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Clause::Builder::adoptText(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Clause::Builder::disownText() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool RecordRef::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool RecordRef::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader RecordRef::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder RecordRef::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void RecordRef::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder RecordRef::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void RecordRef::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> RecordRef::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::stubs::RecordKind RecordRef::Reader::getKind() const {
  return _reader.getDataField< ::stubs::RecordKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::stubs::RecordKind RecordRef::Builder::getKind() {
  return _builder.getDataField< ::stubs::RecordKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void RecordRef::Builder::setKind( ::stubs::RecordKind value) {
  _builder.setDataField< ::stubs::RecordKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Param::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Param::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Type>::Reader Param::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Type>::Builder Param::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Type>::Pipeline Param::Pipeline::getType() {
  return  ::stubs::Node< ::stubs::Type>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Param::Builder::setType( ::stubs::Node< ::stubs::Type>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Type>::Builder Param::Builder::initType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Param::Builder::adoptType(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> Param::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Param::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Param::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Param::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Param::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Param::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Param::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Param::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Param::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Param::Reader::hasDefault() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Param::Builder::hasDefault() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Param::Reader::getDefault() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Param::Builder::getDefault() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Param::Pipeline::getDefault() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Param::Builder::setDefault( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Param::Builder::initDefault() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Param::Builder::adoptDefault(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Param::Builder::disownDefault() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::stubs::Type::Which Type::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::stubs::Type::Which Type::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Type::Reader::isUnionNotInitialized() const {
  return which() == Type::UNION_NOT_INITIALIZED;
}
inline bool Type::Builder::isUnionNotInitialized() {
  return which() == Type::UNION_NOT_INITIALIZED;
}
inline  ::capnp::Void Type::Reader::getUnionNotInitialized() const {
  KJ_IREQUIRE((which() == Type::UNION_NOT_INITIALIZED),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Type::Builder::getUnionNotInitialized() {
  KJ_IREQUIRE((which() == Type::UNION_NOT_INITIALIZED),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setUnionNotInitialized( ::capnp::Void value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::UNION_NOT_INITIALIZED);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isBuiltin() const {
  return which() == Type::BUILTIN;
}
inline bool Type::Builder::isBuiltin() {
  return which() == Type::BUILTIN;
}
inline  ::stubs::Type::BuiltinKind Type::Reader::getBuiltin() const {
  KJ_IREQUIRE((which() == Type::BUILTIN),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::stubs::Type::BuiltinKind>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::stubs::Type::BuiltinKind Type::Builder::getBuiltin() {
  KJ_IREQUIRE((which() == Type::BUILTIN),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::stubs::Type::BuiltinKind>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Type::Builder::setBuiltin( ::stubs::Type::BuiltinKind value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::BUILTIN);
  _builder.setDataField< ::stubs::Type::BuiltinKind>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Type::Reader::isPointer() const {
  return which() == Type::POINTER;
}
inline bool Type::Builder::isPointer() {
  return which() == Type::POINTER;
}
inline bool Type::Reader::hasPointer() const {
  if (which() != Type::POINTER) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::Builder::hasPointer() {
  if (which() != Type::POINTER) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Type>::Reader Type::Reader::getPointer() const {
  KJ_IREQUIRE((which() == Type::POINTER),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Type>::Builder Type::Builder::getPointer() {
  KJ_IREQUIRE((which() == Type::POINTER),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::setPointer( ::stubs::Node< ::stubs::Type>::Reader value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::POINTER);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Type>::Builder Type::Builder::initPointer() {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::POINTER);
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::adoptPointer(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::POINTER);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> Type::Builder::disownPointer() {
  KJ_IREQUIRE((which() == Type::POINTER),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Type::Reader::isRecord() const {
  return which() == Type::RECORD;
}
inline bool Type::Builder::isRecord() {
  return which() == Type::RECORD;
}
inline bool Type::Reader::hasRecord() const {
  if (which() != Type::RECORD) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::Builder::hasRecord() {
  if (which() != Type::RECORD) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::RecordRef::Reader Type::Reader::getRecord() const {
  KJ_IREQUIRE((which() == Type::RECORD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::RecordRef::Builder Type::Builder::getRecord() {
  KJ_IREQUIRE((which() == Type::RECORD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::setRecord( ::stubs::RecordRef::Reader value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::RECORD);
  ::capnp::_::PointerHelpers< ::stubs::RecordRef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::RecordRef::Builder Type::Builder::initRecord() {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::RECORD);
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::adoptRecord(
    ::capnp::Orphan< ::stubs::RecordRef>&& value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::RECORD);
  ::capnp::_::PointerHelpers< ::stubs::RecordRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::RecordRef> Type::Builder::disownRecord() {
  KJ_IREQUIRE((which() == Type::RECORD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Type::Reader::isEnumType() const {
  return which() == Type::ENUM_TYPE;
}
inline bool Type::Builder::isEnumType() {
  return which() == Type::ENUM_TYPE;
}
inline bool Type::Reader::hasEnumType() const {
  if (which() != Type::ENUM_TYPE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::Builder::hasEnumType() {
  if (which() != Type::ENUM_TYPE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Type::Reader::getEnumType() const {
  KJ_IREQUIRE((which() == Type::ENUM_TYPE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Type::Builder::getEnumType() {
  KJ_IREQUIRE((which() == Type::ENUM_TYPE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::setEnumType( ::capnp::Text::Reader value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::ENUM_TYPE);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Type::Builder::initEnumType(unsigned int size) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::ENUM_TYPE);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Type::Builder::adoptEnumType(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::ENUM_TYPE);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Type::Builder::disownEnumType() {
  KJ_IREQUIRE((which() == Type::ENUM_TYPE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Type::Reader::isLValueRef() const {
  return which() == Type::L_VALUE_REF;
}
inline bool Type::Builder::isLValueRef() {
  return which() == Type::L_VALUE_REF;
}
inline bool Type::Reader::hasLValueRef() const {
  if (which() != Type::L_VALUE_REF) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::Builder::hasLValueRef() {
  if (which() != Type::L_VALUE_REF) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Type>::Reader Type::Reader::getLValueRef() const {
  KJ_IREQUIRE((which() == Type::L_VALUE_REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Type>::Builder Type::Builder::getLValueRef() {
  KJ_IREQUIRE((which() == Type::L_VALUE_REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::setLValueRef( ::stubs::Node< ::stubs::Type>::Reader value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::L_VALUE_REF);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Type>::Builder Type::Builder::initLValueRef() {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::L_VALUE_REF);
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::adoptLValueRef(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::L_VALUE_REF);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> Type::Builder::disownLValueRef() {
  KJ_IREQUIRE((which() == Type::L_VALUE_REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Type::Reader::isRValueRef() const {
  return which() == Type::R_VALUE_REF;
}
inline bool Type::Builder::isRValueRef() {
  return which() == Type::R_VALUE_REF;
}
inline bool Type::Reader::hasRValueRef() const {
  if (which() != Type::R_VALUE_REF) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::Builder::hasRValueRef() {
  if (which() != Type::R_VALUE_REF) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Type>::Reader Type::Reader::getRValueRef() const {
  KJ_IREQUIRE((which() == Type::R_VALUE_REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Type>::Builder Type::Builder::getRValueRef() {
  KJ_IREQUIRE((which() == Type::R_VALUE_REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::setRValueRef( ::stubs::Node< ::stubs::Type>::Reader value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::R_VALUE_REF);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Type>::Builder Type::Builder::initRValueRef() {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::R_VALUE_REF);
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::adoptRValueRef(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::R_VALUE_REF);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> Type::Builder::disownRValueRef() {
  KJ_IREQUIRE((which() == Type::R_VALUE_REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Type::Reader::isFixedWidth() const {
  return which() == Type::FIXED_WIDTH;
}
inline bool Type::Builder::isFixedWidth() {
  return which() == Type::FIXED_WIDTH;
}
inline bool Type::Reader::hasFixedWidth() const {
  if (which() != Type::FIXED_WIDTH) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::Builder::hasFixedWidth() {
  if (which() != Type::FIXED_WIDTH) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Type::FixedWidth::Reader Type::Reader::getFixedWidth() const {
  KJ_IREQUIRE((which() == Type::FIXED_WIDTH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Type::FixedWidth>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Type::FixedWidth::Builder Type::Builder::getFixedWidth() {
  KJ_IREQUIRE((which() == Type::FIXED_WIDTH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Type::FixedWidth>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::setFixedWidth( ::stubs::Type::FixedWidth::Reader value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::FIXED_WIDTH);
  ::capnp::_::PointerHelpers< ::stubs::Type::FixedWidth>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Type::FixedWidth::Builder Type::Builder::initFixedWidth() {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::FIXED_WIDTH);
  return ::capnp::_::PointerHelpers< ::stubs::Type::FixedWidth>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::adoptFixedWidth(
    ::capnp::Orphan< ::stubs::Type::FixedWidth>&& value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::FIXED_WIDTH);
  ::capnp::_::PointerHelpers< ::stubs::Type::FixedWidth>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Type::FixedWidth> Type::Builder::disownFixedWidth() {
  KJ_IREQUIRE((which() == Type::FIXED_WIDTH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Type::FixedWidth>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Type::Reader::isElaborated() const {
  return which() == Type::ELABORATED;
}
inline bool Type::Builder::isElaborated() {
  return which() == Type::ELABORATED;
}
inline bool Type::Reader::hasElaborated() const {
  if (which() != Type::ELABORATED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::Builder::hasElaborated() {
  if (which() != Type::ELABORATED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Type>::Reader Type::Reader::getElaborated() const {
  KJ_IREQUIRE((which() == Type::ELABORATED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Type>::Builder Type::Builder::getElaborated() {
  KJ_IREQUIRE((which() == Type::ELABORATED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::setElaborated( ::stubs::Node< ::stubs::Type>::Reader value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::ELABORATED);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Type>::Builder Type::Builder::initElaborated() {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::ELABORATED);
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::adoptElaborated(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::ELABORATED);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> Type::Builder::disownElaborated() {
  KJ_IREQUIRE((which() == Type::ELABORATED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Type::Reader::isTypedef() const {
  return which() == Type::TYPEDEF;
}
inline bool Type::Builder::isTypedef() {
  return which() == Type::TYPEDEF;
}
inline bool Type::Reader::hasTypedef() const {
  if (which() != Type::TYPEDEF) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::Builder::hasTypedef() {
  if (which() != Type::TYPEDEF) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Type::Reader::getTypedef() const {
  KJ_IREQUIRE((which() == Type::TYPEDEF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Type::Builder::getTypedef() {
  KJ_IREQUIRE((which() == Type::TYPEDEF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::setTypedef( ::capnp::Text::Reader value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::TYPEDEF);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Type::Builder::initTypedef(unsigned int size) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::TYPEDEF);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Type::Builder::adoptTypedef(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::TYPEDEF);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Type::Builder::disownTypedef() {
  KJ_IREQUIRE((which() == Type::TYPEDEF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Type::Reader::isFunctionProto() const {
  return which() == Type::FUNCTION_PROTO;
}
inline bool Type::Builder::isFunctionProto() {
  return which() == Type::FUNCTION_PROTO;
}
inline bool Type::Reader::hasFunctionProto() const {
  if (which() != Type::FUNCTION_PROTO) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::Builder::hasFunctionProto() {
  if (which() != Type::FUNCTION_PROTO) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Type::FunctionProto::Reader Type::Reader::getFunctionProto() const {
  KJ_IREQUIRE((which() == Type::FUNCTION_PROTO),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Type::FunctionProto>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Type::FunctionProto::Builder Type::Builder::getFunctionProto() {
  KJ_IREQUIRE((which() == Type::FUNCTION_PROTO),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Type::FunctionProto>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::setFunctionProto( ::stubs::Type::FunctionProto::Reader value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::FUNCTION_PROTO);
  ::capnp::_::PointerHelpers< ::stubs::Type::FunctionProto>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Type::FunctionProto::Builder Type::Builder::initFunctionProto() {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::FUNCTION_PROTO);
  return ::capnp::_::PointerHelpers< ::stubs::Type::FunctionProto>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::adoptFunctionProto(
    ::capnp::Orphan< ::stubs::Type::FunctionProto>&& value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::FUNCTION_PROTO);
  ::capnp::_::PointerHelpers< ::stubs::Type::FunctionProto>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Type::FunctionProto> Type::Builder::disownFunctionProto() {
  KJ_IREQUIRE((which() == Type::FUNCTION_PROTO),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Type::FunctionProto>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Type::Reader::isSubstTemplateTypeParam() const {
  return which() == Type::SUBST_TEMPLATE_TYPE_PARAM;
}
inline bool Type::Builder::isSubstTemplateTypeParam() {
  return which() == Type::SUBST_TEMPLATE_TYPE_PARAM;
}
inline bool Type::Reader::hasSubstTemplateTypeParam() const {
  if (which() != Type::SUBST_TEMPLATE_TYPE_PARAM) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::Builder::hasSubstTemplateTypeParam() {
  if (which() != Type::SUBST_TEMPLATE_TYPE_PARAM) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Type>::Reader Type::Reader::getSubstTemplateTypeParam() const {
  KJ_IREQUIRE((which() == Type::SUBST_TEMPLATE_TYPE_PARAM),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Type>::Builder Type::Builder::getSubstTemplateTypeParam() {
  KJ_IREQUIRE((which() == Type::SUBST_TEMPLATE_TYPE_PARAM),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::setSubstTemplateTypeParam( ::stubs::Node< ::stubs::Type>::Reader value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::SUBST_TEMPLATE_TYPE_PARAM);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Type>::Builder Type::Builder::initSubstTemplateTypeParam() {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::SUBST_TEMPLATE_TYPE_PARAM);
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::Builder::adoptSubstTemplateTypeParam(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value) {
  _builder.setDataField<Type::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Type::SUBST_TEMPLATE_TYPE_PARAM);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> Type::Builder::disownSubstTemplateTypeParam() {
  KJ_IREQUIRE((which() == Type::SUBST_TEMPLATE_TYPE_PARAM),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::stubs::Type::FixedWidth::FixedWidthKind Type::FixedWidth::Reader::getKind() const {
  return _reader.getDataField< ::stubs::Type::FixedWidth::FixedWidthKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::stubs::Type::FixedWidth::FixedWidthKind Type::FixedWidth::Builder::getKind() {
  return _builder.getDataField< ::stubs::Type::FixedWidth::FixedWidthKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Type::FixedWidth::Builder::setKind( ::stubs::Type::FixedWidth::FixedWidthKind value) {
  _builder.setDataField< ::stubs::Type::FixedWidth::FixedWidthKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t Type::FixedWidth::Reader::getBits() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t Type::FixedWidth::Builder::getBits() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Type::FixedWidth::Builder::setBits( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Type::FunctionProto::Reader::hasReturnType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Type::FunctionProto::Builder::hasReturnType() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Type>::Reader Type::FunctionProto::Reader::getReturnType() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Type>::Builder Type::FunctionProto::Builder::getReturnType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Type>::Pipeline Type::FunctionProto::Pipeline::getReturnType() {
  return  ::stubs::Node< ::stubs::Type>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Type::FunctionProto::Builder::setReturnType( ::stubs::Node< ::stubs::Type>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Type>::Builder Type::FunctionProto::Builder::initReturnType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Type::FunctionProto::Builder::adoptReturnType(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> Type::FunctionProto::Builder::disownReturnType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Type::FunctionProto::Reader::hasGhostParams() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Type::FunctionProto::Builder::hasGhostParams() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader Type::FunctionProto::Reader::getGhostParams() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder Type::FunctionProto::Builder::getGhostParams() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Type::FunctionProto::Builder::setGhostParams( ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder Type::FunctionProto::Builder::initGhostParams(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Type::FunctionProto::Builder::adoptGhostParams(
    ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>> Type::FunctionProto::Builder::disownGhostParams() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Type::FunctionProto::Reader::hasParams() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Type::FunctionProto::Builder::hasParams() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Reader Type::FunctionProto::Reader::getParams() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Builder Type::FunctionProto::Builder::getParams() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Type::FunctionProto::Builder::setParams( ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Builder Type::FunctionProto::Builder::initParams(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Type::FunctionProto::Builder::adoptParams(
    ::capnp::Orphan< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>> Type::FunctionProto::Builder::disownParams() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Type::FunctionProto::Reader::hasContract() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Type::FunctionProto::Builder::hasContract() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader Type::FunctionProto::Reader::getContract() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder Type::FunctionProto::Builder::getContract() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Type::FunctionProto::Builder::setContract( ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder Type::FunctionProto::Builder::initContract(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Type::FunctionProto::Builder::adoptContract(
    ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>> Type::FunctionProto::Builder::disownContract() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline  ::stubs::Stmt::Which Stmt::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::stubs::Stmt::Which Stmt::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Stmt::Reader::isUnionNotInitialized() const {
  return which() == Stmt::UNION_NOT_INITIALIZED;
}
inline bool Stmt::Builder::isUnionNotInitialized() {
  return which() == Stmt::UNION_NOT_INITIALIZED;
}
inline  ::capnp::Void Stmt::Reader::getUnionNotInitialized() const {
  KJ_IREQUIRE((which() == Stmt::UNION_NOT_INITIALIZED),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Stmt::Builder::getUnionNotInitialized() {
  KJ_IREQUIRE((which() == Stmt::UNION_NOT_INITIALIZED),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Stmt::Builder::setUnionNotInitialized( ::capnp::Void value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::UNION_NOT_INITIALIZED);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Stmt::Reader::isAnn() const {
  return which() == Stmt::ANN;
}
inline bool Stmt::Builder::isAnn() {
  return which() == Stmt::ANN;
}
inline bool Stmt::Reader::hasAnn() const {
  if (which() != Stmt::ANN) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Builder::hasAnn() {
  if (which() != Stmt::ANN) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Stmt::Reader::getAnn() const {
  KJ_IREQUIRE((which() == Stmt::ANN),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Stmt::Builder::getAnn() {
  KJ_IREQUIRE((which() == Stmt::ANN),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::setAnn( ::capnp::Text::Reader value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::ANN);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Stmt::Builder::initAnn(unsigned int size) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::ANN);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Stmt::Builder::adoptAnn(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::ANN);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Stmt::Builder::disownAnn() {
  KJ_IREQUIRE((which() == Stmt::ANN),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Reader::isDecl() const {
  return which() == Stmt::DECL;
}
inline bool Stmt::Builder::isDecl() {
  return which() == Stmt::DECL;
}
inline bool Stmt::Reader::hasDecl() const {
  if (which() != Stmt::DECL) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Builder::hasDecl() {
  if (which() != Stmt::DECL) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader Stmt::Reader::getDecl() const {
  KJ_IREQUIRE((which() == Stmt::DECL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder Stmt::Builder::getDecl() {
  KJ_IREQUIRE((which() == Stmt::DECL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::setDecl( ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::DECL);
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder Stmt::Builder::initDecl(unsigned int size) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::DECL);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Stmt::Builder::adoptDecl(
    ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>&& value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::DECL);
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>> Stmt::Builder::disownDecl() {
  KJ_IREQUIRE((which() == Stmt::DECL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Reader::isCompound() const {
  return which() == Stmt::COMPOUND;
}
inline bool Stmt::Builder::isCompound() {
  return which() == Stmt::COMPOUND;
}
inline bool Stmt::Reader::hasCompound() const {
  if (which() != Stmt::COMPOUND) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Builder::hasCompound() {
  if (which() != Stmt::COMPOUND) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Stmt::Compound::Reader Stmt::Reader::getCompound() const {
  KJ_IREQUIRE((which() == Stmt::COMPOUND),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Compound>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Stmt::Compound::Builder Stmt::Builder::getCompound() {
  KJ_IREQUIRE((which() == Stmt::COMPOUND),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Compound>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::setCompound( ::stubs::Stmt::Compound::Reader value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::COMPOUND);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::Compound>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Stmt::Compound::Builder Stmt::Builder::initCompound() {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::COMPOUND);
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Compound>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::adoptCompound(
    ::capnp::Orphan< ::stubs::Stmt::Compound>&& value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::COMPOUND);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::Compound>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Stmt::Compound> Stmt::Builder::disownCompound() {
  KJ_IREQUIRE((which() == Stmt::COMPOUND),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Compound>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Reader::isExpr() const {
  return which() == Stmt::EXPR;
}
inline bool Stmt::Builder::isExpr() {
  return which() == Stmt::EXPR;
}
inline bool Stmt::Reader::hasExpr() const {
  if (which() != Stmt::EXPR) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Builder::hasExpr() {
  if (which() != Stmt::EXPR) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Stmt::Reader::getExpr() const {
  KJ_IREQUIRE((which() == Stmt::EXPR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Stmt::Builder::getExpr() {
  KJ_IREQUIRE((which() == Stmt::EXPR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::setExpr( ::stubs::Node< ::stubs::Expr>::Reader value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::EXPR);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Stmt::Builder::initExpr() {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::EXPR);
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::adoptExpr(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::EXPR);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Stmt::Builder::disownExpr() {
  KJ_IREQUIRE((which() == Stmt::EXPR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Reader::isReturn() const {
  return which() == Stmt::RETURN;
}
inline bool Stmt::Builder::isReturn() {
  return which() == Stmt::RETURN;
}
inline bool Stmt::Reader::hasReturn() const {
  if (which() != Stmt::RETURN) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Builder::hasReturn() {
  if (which() != Stmt::RETURN) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Stmt::Return::Reader Stmt::Reader::getReturn() const {
  KJ_IREQUIRE((which() == Stmt::RETURN),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Return>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Stmt::Return::Builder Stmt::Builder::getReturn() {
  KJ_IREQUIRE((which() == Stmt::RETURN),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Return>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::setReturn( ::stubs::Stmt::Return::Reader value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::RETURN);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::Return>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Stmt::Return::Builder Stmt::Builder::initReturn() {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::RETURN);
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Return>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::adoptReturn(
    ::capnp::Orphan< ::stubs::Stmt::Return>&& value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::RETURN);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::Return>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Stmt::Return> Stmt::Builder::disownReturn() {
  KJ_IREQUIRE((which() == Stmt::RETURN),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Return>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Reader::isIf() const {
  return which() == Stmt::IF;
}
inline bool Stmt::Builder::isIf() {
  return which() == Stmt::IF;
}
inline bool Stmt::Reader::hasIf() const {
  if (which() != Stmt::IF) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Builder::hasIf() {
  if (which() != Stmt::IF) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Stmt::If::Reader Stmt::Reader::getIf() const {
  KJ_IREQUIRE((which() == Stmt::IF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::If>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Stmt::If::Builder Stmt::Builder::getIf() {
  KJ_IREQUIRE((which() == Stmt::IF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::If>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::setIf( ::stubs::Stmt::If::Reader value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::IF);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::If>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Stmt::If::Builder Stmt::Builder::initIf() {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::IF);
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::If>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::adoptIf(
    ::capnp::Orphan< ::stubs::Stmt::If>&& value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::IF);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::If>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Stmt::If> Stmt::Builder::disownIf() {
  KJ_IREQUIRE((which() == Stmt::IF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::If>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Reader::isNull() const {
  return which() == Stmt::NULL_;
}
inline bool Stmt::Builder::isNull() {
  return which() == Stmt::NULL_;
}
inline  ::capnp::Void Stmt::Reader::getNull() const {
  KJ_IREQUIRE((which() == Stmt::NULL_),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Stmt::Builder::getNull() {
  KJ_IREQUIRE((which() == Stmt::NULL_),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Stmt::Builder::setNull( ::capnp::Void value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::NULL_);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Stmt::Reader::isWhile() const {
  return which() == Stmt::WHILE;
}
inline bool Stmt::Builder::isWhile() {
  return which() == Stmt::WHILE;
}
inline bool Stmt::Reader::hasWhile() const {
  if (which() != Stmt::WHILE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Builder::hasWhile() {
  if (which() != Stmt::WHILE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Stmt::While::Reader Stmt::Reader::getWhile() const {
  KJ_IREQUIRE((which() == Stmt::WHILE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::While>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Stmt::While::Builder Stmt::Builder::getWhile() {
  KJ_IREQUIRE((which() == Stmt::WHILE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::While>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::setWhile( ::stubs::Stmt::While::Reader value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::WHILE);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::While>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Stmt::While::Builder Stmt::Builder::initWhile() {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::WHILE);
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::While>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::adoptWhile(
    ::capnp::Orphan< ::stubs::Stmt::While>&& value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::WHILE);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::While>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Stmt::While> Stmt::Builder::disownWhile() {
  KJ_IREQUIRE((which() == Stmt::WHILE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::While>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Reader::isDoWhile() const {
  return which() == Stmt::DO_WHILE;
}
inline bool Stmt::Builder::isDoWhile() {
  return which() == Stmt::DO_WHILE;
}
inline bool Stmt::Reader::hasDoWhile() const {
  if (which() != Stmt::DO_WHILE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Builder::hasDoWhile() {
  if (which() != Stmt::DO_WHILE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Stmt::While::Reader Stmt::Reader::getDoWhile() const {
  KJ_IREQUIRE((which() == Stmt::DO_WHILE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::While>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Stmt::While::Builder Stmt::Builder::getDoWhile() {
  KJ_IREQUIRE((which() == Stmt::DO_WHILE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::While>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::setDoWhile( ::stubs::Stmt::While::Reader value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::DO_WHILE);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::While>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Stmt::While::Builder Stmt::Builder::initDoWhile() {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::DO_WHILE);
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::While>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::adoptDoWhile(
    ::capnp::Orphan< ::stubs::Stmt::While>&& value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::DO_WHILE);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::While>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Stmt::While> Stmt::Builder::disownDoWhile() {
  KJ_IREQUIRE((which() == Stmt::DO_WHILE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::While>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Reader::isBreak() const {
  return which() == Stmt::BREAK;
}
inline bool Stmt::Builder::isBreak() {
  return which() == Stmt::BREAK;
}
inline  ::capnp::Void Stmt::Reader::getBreak() const {
  KJ_IREQUIRE((which() == Stmt::BREAK),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Stmt::Builder::getBreak() {
  KJ_IREQUIRE((which() == Stmt::BREAK),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Stmt::Builder::setBreak( ::capnp::Void value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::BREAK);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Stmt::Reader::isContinue() const {
  return which() == Stmt::CONTINUE;
}
inline bool Stmt::Builder::isContinue() {
  return which() == Stmt::CONTINUE;
}
inline  ::capnp::Void Stmt::Reader::getContinue() const {
  KJ_IREQUIRE((which() == Stmt::CONTINUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Stmt::Builder::getContinue() {
  KJ_IREQUIRE((which() == Stmt::CONTINUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Stmt::Builder::setContinue( ::capnp::Void value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::CONTINUE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Stmt::Reader::isSwitch() const {
  return which() == Stmt::SWITCH;
}
inline bool Stmt::Builder::isSwitch() {
  return which() == Stmt::SWITCH;
}
inline bool Stmt::Reader::hasSwitch() const {
  if (which() != Stmt::SWITCH) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Builder::hasSwitch() {
  if (which() != Stmt::SWITCH) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Stmt::Switch::Reader Stmt::Reader::getSwitch() const {
  KJ_IREQUIRE((which() == Stmt::SWITCH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Switch>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Stmt::Switch::Builder Stmt::Builder::getSwitch() {
  KJ_IREQUIRE((which() == Stmt::SWITCH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Switch>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::setSwitch( ::stubs::Stmt::Switch::Reader value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::SWITCH);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::Switch>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Stmt::Switch::Builder Stmt::Builder::initSwitch() {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::SWITCH);
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Switch>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::adoptSwitch(
    ::capnp::Orphan< ::stubs::Stmt::Switch>&& value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::SWITCH);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::Switch>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Stmt::Switch> Stmt::Builder::disownSwitch() {
  KJ_IREQUIRE((which() == Stmt::SWITCH),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Switch>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Reader::isCase() const {
  return which() == Stmt::CASE;
}
inline bool Stmt::Builder::isCase() {
  return which() == Stmt::CASE;
}
inline bool Stmt::Reader::hasCase() const {
  if (which() != Stmt::CASE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Builder::hasCase() {
  if (which() != Stmt::CASE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Stmt::Case::Reader Stmt::Reader::getCase() const {
  KJ_IREQUIRE((which() == Stmt::CASE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Case>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Stmt::Case::Builder Stmt::Builder::getCase() {
  KJ_IREQUIRE((which() == Stmt::CASE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Case>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::setCase( ::stubs::Stmt::Case::Reader value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::CASE);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::Case>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Stmt::Case::Builder Stmt::Builder::initCase() {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::CASE);
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Case>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::adoptCase(
    ::capnp::Orphan< ::stubs::Stmt::Case>&& value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::CASE);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::Case>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Stmt::Case> Stmt::Builder::disownCase() {
  KJ_IREQUIRE((which() == Stmt::CASE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::Case>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Reader::isDefCase() const {
  return which() == Stmt::DEF_CASE;
}
inline bool Stmt::Builder::isDefCase() {
  return which() == Stmt::DEF_CASE;
}
inline bool Stmt::Reader::hasDefCase() const {
  if (which() != Stmt::DEF_CASE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Builder::hasDefCase() {
  if (which() != Stmt::DEF_CASE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Stmt::DefCase::Reader Stmt::Reader::getDefCase() const {
  KJ_IREQUIRE((which() == Stmt::DEF_CASE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::DefCase>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Stmt::DefCase::Builder Stmt::Builder::getDefCase() {
  KJ_IREQUIRE((which() == Stmt::DEF_CASE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::DefCase>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::setDefCase( ::stubs::Stmt::DefCase::Reader value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::DEF_CASE);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::DefCase>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Stmt::DefCase::Builder Stmt::Builder::initDefCase() {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::DEF_CASE);
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::DefCase>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Builder::adoptDefCase(
    ::capnp::Orphan< ::stubs::Stmt::DefCase>&& value) {
  _builder.setDataField<Stmt::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Stmt::DEF_CASE);
  ::capnp::_::PointerHelpers< ::stubs::Stmt::DefCase>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Stmt::DefCase> Stmt::Builder::disownDefCase() {
  KJ_IREQUIRE((which() == Stmt::DEF_CASE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Stmt::DefCase>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Return::Reader::hasExpr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Return::Builder::hasExpr() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Stmt::Return::Reader::getExpr() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Stmt::Return::Builder::getExpr() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Stmt::Return::Pipeline::getExpr() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Stmt::Return::Builder::setExpr( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Stmt::Return::Builder::initExpr() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Return::Builder::adoptExpr(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Stmt::Return::Builder::disownExpr() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::If::Reader::hasCond() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::If::Builder::hasCond() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Stmt::If::Reader::getCond() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Stmt::If::Builder::getCond() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Stmt::If::Pipeline::getCond() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Stmt::If::Builder::setCond( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Stmt::If::Builder::initCond() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::If::Builder::adoptCond(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Stmt::If::Builder::disownCond() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::If::Reader::hasThen() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::If::Builder::hasThen() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Stmt>::Reader Stmt::If::Reader::getThen() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Stmt>::Builder Stmt::If::Builder::getThen() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Stmt>::Pipeline Stmt::If::Pipeline::getThen() {
  return  ::stubs::Node< ::stubs::Stmt>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Stmt::If::Builder::setThen( ::stubs::Node< ::stubs::Stmt>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Stmt>::Builder Stmt::If::Builder::initThen() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Stmt::If::Builder::adoptThen(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>> Stmt::If::Builder::disownThen() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Stmt::If::Reader::hasElse() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::If::Builder::hasElse() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Stmt>::Reader Stmt::If::Reader::getElse() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Stmt>::Builder Stmt::If::Builder::getElse() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Stmt>::Pipeline Stmt::If::Pipeline::getElse() {
  return  ::stubs::Node< ::stubs::Stmt>::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Stmt::If::Builder::setElse( ::stubs::Node< ::stubs::Stmt>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Stmt>::Builder Stmt::If::Builder::initElse() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Stmt::If::Builder::adoptElse(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>> Stmt::If::Builder::disownElse() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Stmt::Compound::Reader::hasStmts() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Compound::Builder::hasStmts() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Reader Stmt::Compound::Reader::getStmts() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Builder Stmt::Compound::Builder::getStmts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Compound::Builder::setStmts( ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Builder Stmt::Compound::Builder::initStmts(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Stmt::Compound::Builder::adoptStmts(
    ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>> Stmt::Compound::Builder::disownStmts() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Compound::Reader::hasRBrace() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Compound::Builder::hasRBrace() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Loc::Reader Stmt::Compound::Reader::getRBrace() const {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Loc::Builder Stmt::Compound::Builder::getRBrace() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Loc::Pipeline Stmt::Compound::Pipeline::getRBrace() {
  return  ::stubs::Loc::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Stmt::Compound::Builder::setRBrace( ::stubs::Loc::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Loc::Builder Stmt::Compound::Builder::initRBrace() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Stmt::Compound::Builder::adoptRBrace(
    ::capnp::Orphan< ::stubs::Loc>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Loc> Stmt::Compound::Builder::disownRBrace() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Stmt::While::Reader::hasCond() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::While::Builder::hasCond() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Stmt::While::Reader::getCond() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Stmt::While::Builder::getCond() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Stmt::While::Pipeline::getCond() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Stmt::While::Builder::setCond( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Stmt::While::Builder::initCond() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::While::Builder::adoptCond(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Stmt::While::Builder::disownCond() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::While::Reader::hasBody() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::While::Builder::hasBody() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Stmt>::Reader Stmt::While::Reader::getBody() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Stmt>::Builder Stmt::While::Builder::getBody() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Stmt>::Pipeline Stmt::While::Pipeline::getBody() {
  return  ::stubs::Node< ::stubs::Stmt>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Stmt::While::Builder::setBody( ::stubs::Node< ::stubs::Stmt>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Stmt>::Builder Stmt::While::Builder::initBody() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Stmt::While::Builder::adoptBody(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>> Stmt::While::Builder::disownBody() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Stmt::While::Reader::hasSpec() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::While::Builder::hasSpec() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader Stmt::While::Reader::getSpec() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder Stmt::While::Builder::getSpec() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Stmt::While::Builder::setSpec( ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder Stmt::While::Builder::initSpec(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Stmt::While::Builder::adoptSpec(
    ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>> Stmt::While::Builder::disownSpec() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Stmt::While::Reader::hasWhileLoc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::While::Builder::hasWhileLoc() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Loc::Reader Stmt::While::Reader::getWhileLoc() const {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::stubs::Loc::Builder Stmt::While::Builder::getWhileLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Loc::Pipeline Stmt::While::Pipeline::getWhileLoc() {
  return  ::stubs::Loc::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Stmt::While::Builder::setWhileLoc( ::stubs::Loc::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Loc::Builder Stmt::While::Builder::initWhileLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Stmt::While::Builder::adoptWhileLoc(
    ::capnp::Orphan< ::stubs::Loc>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Loc> Stmt::While::Builder::disownWhileLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Stmt::Case::Reader::hasLhs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Case::Builder::hasLhs() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Stmt::Case::Reader::getLhs() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Stmt::Case::Builder::getLhs() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Stmt::Case::Pipeline::getLhs() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Stmt::Case::Builder::setLhs( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Stmt::Case::Builder::initLhs() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Case::Builder::adoptLhs(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Stmt::Case::Builder::disownLhs() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Case::Reader::hasStmt() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Case::Builder::hasStmt() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Stmt>::Reader Stmt::Case::Reader::getStmt() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Stmt>::Builder Stmt::Case::Builder::getStmt() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Stmt>::Pipeline Stmt::Case::Pipeline::getStmt() {
  return  ::stubs::Node< ::stubs::Stmt>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Stmt::Case::Builder::setStmt( ::stubs::Node< ::stubs::Stmt>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Stmt>::Builder Stmt::Case::Builder::initStmt() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Stmt::Case::Builder::adoptStmt(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>> Stmt::Case::Builder::disownStmt() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Stmt::DefCase::Reader::hasStmt() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::DefCase::Builder::hasStmt() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Stmt>::Reader Stmt::DefCase::Reader::getStmt() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Stmt>::Builder Stmt::DefCase::Builder::getStmt() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Stmt>::Pipeline Stmt::DefCase::Pipeline::getStmt() {
  return  ::stubs::Node< ::stubs::Stmt>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Stmt::DefCase::Builder::setStmt( ::stubs::Node< ::stubs::Stmt>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Stmt>::Builder Stmt::DefCase::Builder::initStmt() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::DefCase::Builder::adoptStmt(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>> Stmt::DefCase::Builder::disownStmt() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Switch::Reader::hasCond() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Switch::Builder::hasCond() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Stmt::Switch::Reader::getCond() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Stmt::Switch::Builder::getCond() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Stmt::Switch::Pipeline::getCond() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Stmt::Switch::Builder::setCond( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Stmt::Switch::Builder::initCond() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Stmt::Switch::Builder::adoptCond(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Stmt::Switch::Builder::disownCond() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Stmt::Switch::Reader::hasCases() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Stmt::Switch::Builder::hasCases() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Reader Stmt::Switch::Reader::getCases() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Builder Stmt::Switch::Builder::getCases() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Stmt::Switch::Builder::setCases( ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>::Builder Stmt::Switch::Builder::initCases(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Stmt::Switch::Builder::adoptCases(
    ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>> Stmt::Switch::Builder::disownCases() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Stmt>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::stubs::Decl::Which Decl::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::stubs::Decl::Which Decl::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Decl::Reader::isUnionNotInitialized() const {
  return which() == Decl::UNION_NOT_INITIALIZED;
}
inline bool Decl::Builder::isUnionNotInitialized() {
  return which() == Decl::UNION_NOT_INITIALIZED;
}
inline  ::capnp::Void Decl::Reader::getUnionNotInitialized() const {
  KJ_IREQUIRE((which() == Decl::UNION_NOT_INITIALIZED),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Decl::Builder::getUnionNotInitialized() {
  KJ_IREQUIRE((which() == Decl::UNION_NOT_INITIALIZED),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Decl::Builder::setUnionNotInitialized( ::capnp::Void value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::UNION_NOT_INITIALIZED);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Decl::Reader::isAnn() const {
  return which() == Decl::ANN;
}
inline bool Decl::Builder::isAnn() {
  return which() == Decl::ANN;
}
inline bool Decl::Reader::hasAnn() const {
  if (which() != Decl::ANN) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Builder::hasAnn() {
  if (which() != Decl::ANN) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Decl::Reader::getAnn() const {
  KJ_IREQUIRE((which() == Decl::ANN),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Decl::Builder::getAnn() {
  KJ_IREQUIRE((which() == Decl::ANN),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::setAnn( ::capnp::Text::Reader value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::ANN);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Decl::Builder::initAnn(unsigned int size) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::ANN);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Decl::Builder::adoptAnn(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::ANN);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Decl::Builder::disownAnn() {
  KJ_IREQUIRE((which() == Decl::ANN),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Reader::isEmpty() const {
  return which() == Decl::EMPTY;
}
inline bool Decl::Builder::isEmpty() {
  return which() == Decl::EMPTY;
}
inline  ::capnp::Void Decl::Reader::getEmpty() const {
  KJ_IREQUIRE((which() == Decl::EMPTY),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Decl::Builder::getEmpty() {
  KJ_IREQUIRE((which() == Decl::EMPTY),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Decl::Builder::setEmpty( ::capnp::Void value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::EMPTY);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Decl::Reader::isVar() const {
  return which() == Decl::VAR;
}
inline bool Decl::Builder::isVar() {
  return which() == Decl::VAR;
}
inline bool Decl::Reader::hasVar() const {
  if (which() != Decl::VAR) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Builder::hasVar() {
  if (which() != Decl::VAR) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Var::Reader Decl::Reader::getVar() const {
  KJ_IREQUIRE((which() == Decl::VAR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Var>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Var::Builder Decl::Builder::getVar() {
  KJ_IREQUIRE((which() == Decl::VAR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Var>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::setVar( ::stubs::Decl::Var::Reader value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::VAR);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Var>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Var::Builder Decl::Builder::initVar() {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::VAR);
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Var>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::adoptVar(
    ::capnp::Orphan< ::stubs::Decl::Var>&& value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::VAR);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Var>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Var> Decl::Builder::disownVar() {
  KJ_IREQUIRE((which() == Decl::VAR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Var>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Reader::isFunction() const {
  return which() == Decl::FUNCTION;
}
inline bool Decl::Builder::isFunction() {
  return which() == Decl::FUNCTION;
}
inline bool Decl::Reader::hasFunction() const {
  if (which() != Decl::FUNCTION) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Builder::hasFunction() {
  if (which() != Decl::FUNCTION) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Function::Reader Decl::Reader::getFunction() const {
  KJ_IREQUIRE((which() == Decl::FUNCTION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Function>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Function::Builder Decl::Builder::getFunction() {
  KJ_IREQUIRE((which() == Decl::FUNCTION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Function>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::setFunction( ::stubs::Decl::Function::Reader value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::FUNCTION);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Function>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Function::Builder Decl::Builder::initFunction() {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::FUNCTION);
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Function>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::adoptFunction(
    ::capnp::Orphan< ::stubs::Decl::Function>&& value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::FUNCTION);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Function>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Function> Decl::Builder::disownFunction() {
  KJ_IREQUIRE((which() == Decl::FUNCTION),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Function>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Reader::isField() const {
  return which() == Decl::FIELD;
}
inline bool Decl::Builder::isField() {
  return which() == Decl::FIELD;
}
inline bool Decl::Reader::hasField() const {
  if (which() != Decl::FIELD) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Builder::hasField() {
  if (which() != Decl::FIELD) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Field::Reader Decl::Reader::getField() const {
  KJ_IREQUIRE((which() == Decl::FIELD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Field>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Field::Builder Decl::Builder::getField() {
  KJ_IREQUIRE((which() == Decl::FIELD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Field>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::setField( ::stubs::Decl::Field::Reader value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::FIELD);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Field>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Field::Builder Decl::Builder::initField() {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::FIELD);
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Field>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::adoptField(
    ::capnp::Orphan< ::stubs::Decl::Field>&& value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::FIELD);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Field>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Field> Decl::Builder::disownField() {
  KJ_IREQUIRE((which() == Decl::FIELD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Field>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Reader::isRecord() const {
  return which() == Decl::RECORD;
}
inline bool Decl::Builder::isRecord() {
  return which() == Decl::RECORD;
}
inline bool Decl::Reader::hasRecord() const {
  if (which() != Decl::RECORD) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Builder::hasRecord() {
  if (which() != Decl::RECORD) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Record::Reader Decl::Reader::getRecord() const {
  KJ_IREQUIRE((which() == Decl::RECORD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Record>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Record::Builder Decl::Builder::getRecord() {
  KJ_IREQUIRE((which() == Decl::RECORD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Record>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::setRecord( ::stubs::Decl::Record::Reader value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::RECORD);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Record>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Record::Builder Decl::Builder::initRecord() {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::RECORD);
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Record>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::adoptRecord(
    ::capnp::Orphan< ::stubs::Decl::Record>&& value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::RECORD);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Record>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Record> Decl::Builder::disownRecord() {
  KJ_IREQUIRE((which() == Decl::RECORD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Record>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Reader::isMethod() const {
  return which() == Decl::METHOD;
}
inline bool Decl::Builder::isMethod() {
  return which() == Decl::METHOD;
}
inline bool Decl::Reader::hasMethod() const {
  if (which() != Decl::METHOD) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Builder::hasMethod() {
  if (which() != Decl::METHOD) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Method::Reader Decl::Reader::getMethod() const {
  KJ_IREQUIRE((which() == Decl::METHOD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Method::Builder Decl::Builder::getMethod() {
  KJ_IREQUIRE((which() == Decl::METHOD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::setMethod( ::stubs::Decl::Method::Reader value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::METHOD);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Method::Builder Decl::Builder::initMethod() {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::METHOD);
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::adoptMethod(
    ::capnp::Orphan< ::stubs::Decl::Method>&& value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::METHOD);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Method> Decl::Builder::disownMethod() {
  KJ_IREQUIRE((which() == Decl::METHOD),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Reader::isAccessSpec() const {
  return which() == Decl::ACCESS_SPEC;
}
inline bool Decl::Builder::isAccessSpec() {
  return which() == Decl::ACCESS_SPEC;
}
inline  ::capnp::Void Decl::Reader::getAccessSpec() const {
  KJ_IREQUIRE((which() == Decl::ACCESS_SPEC),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Decl::Builder::getAccessSpec() {
  KJ_IREQUIRE((which() == Decl::ACCESS_SPEC),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Decl::Builder::setAccessSpec( ::capnp::Void value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::ACCESS_SPEC);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Decl::Reader::isCtor() const {
  return which() == Decl::CTOR;
}
inline bool Decl::Builder::isCtor() {
  return which() == Decl::CTOR;
}
inline bool Decl::Reader::hasCtor() const {
  if (which() != Decl::CTOR) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Builder::hasCtor() {
  if (which() != Decl::CTOR) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Ctor::Reader Decl::Reader::getCtor() const {
  KJ_IREQUIRE((which() == Decl::CTOR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Ctor>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Ctor::Builder Decl::Builder::getCtor() {
  KJ_IREQUIRE((which() == Decl::CTOR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Ctor>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::setCtor( ::stubs::Decl::Ctor::Reader value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::CTOR);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Ctor>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Ctor::Builder Decl::Builder::initCtor() {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::CTOR);
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Ctor>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::adoptCtor(
    ::capnp::Orphan< ::stubs::Decl::Ctor>&& value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::CTOR);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Ctor>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Ctor> Decl::Builder::disownCtor() {
  KJ_IREQUIRE((which() == Decl::CTOR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Ctor>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Reader::isDtor() const {
  return which() == Decl::DTOR;
}
inline bool Decl::Builder::isDtor() {
  return which() == Decl::DTOR;
}
inline bool Decl::Reader::hasDtor() const {
  if (which() != Decl::DTOR) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Builder::hasDtor() {
  if (which() != Decl::DTOR) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Dtor::Reader Decl::Reader::getDtor() const {
  KJ_IREQUIRE((which() == Decl::DTOR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Dtor>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Dtor::Builder Decl::Builder::getDtor() {
  KJ_IREQUIRE((which() == Decl::DTOR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Dtor>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::setDtor( ::stubs::Decl::Dtor::Reader value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::DTOR);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Dtor>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Dtor::Builder Decl::Builder::initDtor() {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::DTOR);
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Dtor>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::adoptDtor(
    ::capnp::Orphan< ::stubs::Decl::Dtor>&& value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::DTOR);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Dtor>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Dtor> Decl::Builder::disownDtor() {
  KJ_IREQUIRE((which() == Decl::DTOR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Dtor>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Reader::isTypedef() const {
  return which() == Decl::TYPEDEF;
}
inline bool Decl::Builder::isTypedef() {
  return which() == Decl::TYPEDEF;
}
inline bool Decl::Reader::hasTypedef() const {
  if (which() != Decl::TYPEDEF) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Builder::hasTypedef() {
  if (which() != Decl::TYPEDEF) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Typedef::Reader Decl::Reader::getTypedef() const {
  KJ_IREQUIRE((which() == Decl::TYPEDEF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Typedef>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Typedef::Builder Decl::Builder::getTypedef() {
  KJ_IREQUIRE((which() == Decl::TYPEDEF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Typedef>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::setTypedef( ::stubs::Decl::Typedef::Reader value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::TYPEDEF);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Typedef>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Typedef::Builder Decl::Builder::initTypedef() {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::TYPEDEF);
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Typedef>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::adoptTypedef(
    ::capnp::Orphan< ::stubs::Decl::Typedef>&& value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::TYPEDEF);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Typedef>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Typedef> Decl::Builder::disownTypedef() {
  KJ_IREQUIRE((which() == Decl::TYPEDEF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Typedef>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Reader::isEnumDecl() const {
  return which() == Decl::ENUM_DECL;
}
inline bool Decl::Builder::isEnumDecl() {
  return which() == Decl::ENUM_DECL;
}
inline bool Decl::Reader::hasEnumDecl() const {
  if (which() != Decl::ENUM_DECL) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Builder::hasEnumDecl() {
  if (which() != Decl::ENUM_DECL) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Enum::Reader Decl::Reader::getEnumDecl() const {
  KJ_IREQUIRE((which() == Decl::ENUM_DECL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Enum>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Enum::Builder Decl::Builder::getEnumDecl() {
  KJ_IREQUIRE((which() == Decl::ENUM_DECL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Enum>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::setEnumDecl( ::stubs::Decl::Enum::Reader value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::ENUM_DECL);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Enum>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Enum::Builder Decl::Builder::initEnumDecl() {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::ENUM_DECL);
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Enum>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::adoptEnumDecl(
    ::capnp::Orphan< ::stubs::Decl::Enum>&& value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::ENUM_DECL);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Enum>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Enum> Decl::Builder::disownEnumDecl() {
  KJ_IREQUIRE((which() == Decl::ENUM_DECL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Enum>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Reader::isNamespace() const {
  return which() == Decl::NAMESPACE;
}
inline bool Decl::Builder::isNamespace() {
  return which() == Decl::NAMESPACE;
}
inline bool Decl::Reader::hasNamespace() const {
  if (which() != Decl::NAMESPACE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Builder::hasNamespace() {
  if (which() != Decl::NAMESPACE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Namespace::Reader Decl::Reader::getNamespace() const {
  KJ_IREQUIRE((which() == Decl::NAMESPACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Namespace>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Namespace::Builder Decl::Builder::getNamespace() {
  KJ_IREQUIRE((which() == Decl::NAMESPACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Namespace>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::setNamespace( ::stubs::Decl::Namespace::Reader value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::NAMESPACE);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Namespace>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Namespace::Builder Decl::Builder::initNamespace() {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::NAMESPACE);
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Namespace>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::adoptNamespace(
    ::capnp::Orphan< ::stubs::Decl::Namespace>&& value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::NAMESPACE);
  ::capnp::_::PointerHelpers< ::stubs::Decl::Namespace>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Namespace> Decl::Builder::disownNamespace() {
  KJ_IREQUIRE((which() == Decl::NAMESPACE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Namespace>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Reader::isFunctionTemplate() const {
  return which() == Decl::FUNCTION_TEMPLATE;
}
inline bool Decl::Builder::isFunctionTemplate() {
  return which() == Decl::FUNCTION_TEMPLATE;
}
inline bool Decl::Reader::hasFunctionTemplate() const {
  if (which() != Decl::FUNCTION_TEMPLATE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Builder::hasFunctionTemplate() {
  if (which() != Decl::FUNCTION_TEMPLATE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::FunctionTemplate::Reader Decl::Reader::getFunctionTemplate() const {
  KJ_IREQUIRE((which() == Decl::FUNCTION_TEMPLATE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::FunctionTemplate>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::FunctionTemplate::Builder Decl::Builder::getFunctionTemplate() {
  KJ_IREQUIRE((which() == Decl::FUNCTION_TEMPLATE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::FunctionTemplate>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::setFunctionTemplate( ::stubs::Decl::FunctionTemplate::Reader value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::FUNCTION_TEMPLATE);
  ::capnp::_::PointerHelpers< ::stubs::Decl::FunctionTemplate>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::FunctionTemplate::Builder Decl::Builder::initFunctionTemplate() {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::FUNCTION_TEMPLATE);
  return ::capnp::_::PointerHelpers< ::stubs::Decl::FunctionTemplate>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Builder::adoptFunctionTemplate(
    ::capnp::Orphan< ::stubs::Decl::FunctionTemplate>&& value) {
  _builder.setDataField<Decl::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Decl::FUNCTION_TEMPLATE);
  ::capnp::_::PointerHelpers< ::stubs::Decl::FunctionTemplate>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::FunctionTemplate> Decl::Builder::disownFunctionTemplate() {
  KJ_IREQUIRE((which() == Decl::FUNCTION_TEMPLATE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Decl::FunctionTemplate>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Var::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Var::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Decl::Var::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Decl::Var::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Var::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Decl::Var::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Decl::Var::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Decl::Var::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Var::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Var::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Type>::Reader Decl::Var::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Type>::Builder Decl::Var::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Type>::Pipeline Decl::Var::Pipeline::getType() {
  return  ::stubs::Node< ::stubs::Type>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Decl::Var::Builder::setType( ::stubs::Node< ::stubs::Type>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Type>::Builder Decl::Var::Builder::initType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Var::Builder::adoptType(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> Decl::Var::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::Var::Reader::hasInit() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Var::Builder::hasInit() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Var::VarInit::Reader Decl::Var::Reader::getInit() const {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Var::VarInit>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Var::VarInit::Builder Decl::Var::Builder::getInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Var::VarInit>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Decl::Var::VarInit::Pipeline Decl::Var::Pipeline::getInit() {
  return  ::stubs::Decl::Var::VarInit::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Decl::Var::Builder::setInit( ::stubs::Decl::Var::VarInit::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Decl::Var::VarInit>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Var::VarInit::Builder Decl::Var::Builder::initInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Var::VarInit>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Decl::Var::Builder::adoptInit(
    ::capnp::Orphan< ::stubs::Decl::Var::VarInit>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Decl::Var::VarInit>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Var::VarInit> Decl::Var::Builder::disownInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Var::VarInit>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Decl::Var::VarInit::Reader::hasInit() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Var::VarInit::Builder::hasInit() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Decl::Var::VarInit::Reader::getInit() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Decl::Var::VarInit::Builder::getInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Decl::Var::VarInit::Pipeline::getInit() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Decl::Var::VarInit::Builder::setInit( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Decl::Var::VarInit::Builder::initInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Var::VarInit::Builder::adoptInit(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Decl::Var::VarInit::Builder::disownInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::stubs::Decl::Var::InitStyle Decl::Var::VarInit::Reader::getStyle() const {
  return _reader.getDataField< ::stubs::Decl::Var::InitStyle>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::stubs::Decl::Var::InitStyle Decl::Var::VarInit::Builder::getStyle() {
  return _builder.getDataField< ::stubs::Decl::Var::InitStyle>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Decl::Var::VarInit::Builder::setStyle( ::stubs::Decl::Var::InitStyle value) {
  _builder.setDataField< ::stubs::Decl::Var::InitStyle>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Decl::Function::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Function::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Decl::Function::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Decl::Function::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Function::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Decl::Function::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Decl::Function::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Decl::Function::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Function::Reader::hasBody() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Function::Builder::hasBody() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Stmt>::Reader Decl::Function::Reader::getBody() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Stmt>::Builder Decl::Function::Builder::getBody() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Stmt>::Pipeline Decl::Function::Pipeline::getBody() {
  return  ::stubs::Node< ::stubs::Stmt>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Decl::Function::Builder::setBody( ::stubs::Node< ::stubs::Stmt>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Stmt>::Builder Decl::Function::Builder::initBody() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Function::Builder::adoptBody(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Stmt>> Decl::Function::Builder::disownBody() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Stmt>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::Function::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Function::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Type>::Reader Decl::Function::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Type>::Builder Decl::Function::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Type>::Pipeline Decl::Function::Pipeline::getResult() {
  return  ::stubs::Node< ::stubs::Type>::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Decl::Function::Builder::setResult( ::stubs::Node< ::stubs::Type>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Type>::Builder Decl::Function::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Decl::Function::Builder::adoptResult(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> Decl::Function::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Decl::Function::Reader::hasParams() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Function::Builder::hasParams() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Reader Decl::Function::Reader::getParams() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Builder Decl::Function::Builder::getParams() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Decl::Function::Builder::setParams( ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>::Builder Decl::Function::Builder::initParams(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Decl::Function::Builder::adoptParams(
    ::capnp::Orphan< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>> Decl::Function::Builder::disownParams() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Param,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Decl::Function::Reader::hasContract() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Function::Builder::hasContract() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader Decl::Function::Reader::getContract() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder Decl::Function::Builder::getContract() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Decl::Function::Builder::setContract( ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder Decl::Function::Builder::initContract(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void Decl::Function::Builder::adoptContract(
    ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>> Decl::Function::Builder::disownContract() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool Decl::Field::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Field::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Decl::Field::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Decl::Field::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Field::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Decl::Field::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Decl::Field::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Decl::Field::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Field::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Field::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Type>::Reader Decl::Field::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Type>::Builder Decl::Field::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Type>::Pipeline Decl::Field::Pipeline::getType() {
  return  ::stubs::Node< ::stubs::Type>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Decl::Field::Builder::setType( ::stubs::Node< ::stubs::Type>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Type>::Builder Decl::Field::Builder::initType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Field::Builder::adoptType(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> Decl::Field::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::Field::Reader::hasInit() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Field::Builder::hasInit() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Field::FieldInit::Reader Decl::Field::Reader::getInit() const {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Field::FieldInit>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Field::FieldInit::Builder Decl::Field::Builder::getInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Field::FieldInit>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Decl::Field::FieldInit::Pipeline Decl::Field::Pipeline::getInit() {
  return  ::stubs::Decl::Field::FieldInit::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Decl::Field::Builder::setInit( ::stubs::Decl::Field::FieldInit::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Decl::Field::FieldInit>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Field::FieldInit::Builder Decl::Field::Builder::initInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Field::FieldInit>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Decl::Field::Builder::adoptInit(
    ::capnp::Orphan< ::stubs::Decl::Field::FieldInit>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Decl::Field::FieldInit>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Field::FieldInit> Decl::Field::Builder::disownInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Field::FieldInit>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Decl::Field::FieldInit::Reader::hasInit() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Field::FieldInit::Builder::hasInit() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Decl::Field::FieldInit::Reader::getInit() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Decl::Field::FieldInit::Builder::getInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Decl::Field::FieldInit::Pipeline::getInit() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Decl::Field::FieldInit::Builder::setInit( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Decl::Field::FieldInit::Builder::initInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Field::FieldInit::Builder::adoptInit(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Decl::Field::FieldInit::Builder::disownInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::stubs::Decl::Field::InitStyle Decl::Field::FieldInit::Reader::getStyle() const {
  return _reader.getDataField< ::stubs::Decl::Field::InitStyle>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::stubs::Decl::Field::InitStyle Decl::Field::FieldInit::Builder::getStyle() {
  return _builder.getDataField< ::stubs::Decl::Field::InitStyle>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Decl::Field::FieldInit::Builder::setStyle( ::stubs::Decl::Field::InitStyle value) {
  _builder.setDataField< ::stubs::Decl::Field::InitStyle>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Decl::Record::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Record::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Decl::Record::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Decl::Record::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Record::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Decl::Record::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Decl::Record::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Decl::Record::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::stubs::RecordKind Decl::Record::Reader::getKind() const {
  return _reader.getDataField< ::stubs::RecordKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::stubs::RecordKind Decl::Record::Builder::getKind() {
  return _builder.getDataField< ::stubs::RecordKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Decl::Record::Builder::setKind( ::stubs::RecordKind value) {
  _builder.setDataField< ::stubs::RecordKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Decl::Record::Reader::hasBody() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Record::Builder::hasBody() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Record::Body::Reader Decl::Record::Reader::getBody() const {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Record::Body>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Record::Body::Builder Decl::Record::Builder::getBody() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Record::Body>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Decl::Record::Body::Pipeline Decl::Record::Pipeline::getBody() {
  return  ::stubs::Decl::Record::Body::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Decl::Record::Builder::setBody( ::stubs::Decl::Record::Body::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Decl::Record::Body>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Record::Body::Builder Decl::Record::Builder::initBody() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Record::Body>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Record::Builder::adoptBody(
    ::capnp::Orphan< ::stubs::Decl::Record::Body>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Decl::Record::Body>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Record::Body> Decl::Record::Builder::disownBody() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Record::Body>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::Record::BaseSpec::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Record::BaseSpec::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Decl::Record::BaseSpec::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Decl::Record::BaseSpec::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Record::BaseSpec::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Decl::Record::BaseSpec::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Decl::Record::BaseSpec::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Decl::Record::BaseSpec::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Record::BaseSpec::Reader::getVirtual() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Decl::Record::BaseSpec::Builder::getVirtual() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Decl::Record::BaseSpec::Builder::setVirtual(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Decl::Record::Body::Reader::hasDecls() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Record::Body::Builder::hasDecls() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader Decl::Record::Body::Reader::getDecls() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder Decl::Record::Body::Builder::getDecls() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Record::Body::Builder::setDecls( ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder Decl::Record::Body::Builder::initDecls(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Decl::Record::Body::Builder::adoptDecls(
    ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>> Decl::Record::Body::Builder::disownDecls() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Record::Body::Reader::hasBases() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Record::Body::Builder::hasBases() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>::Reader Decl::Record::Body::Reader::getBases() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>::Builder Decl::Record::Body::Builder::getBases() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Record::Body::Builder::setBases( ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>::Builder Decl::Record::Body::Builder::initBases(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Decl::Record::Body::Builder::adoptBases(
    ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>> Decl::Record::Body::Builder::disownBases() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl::Record::BaseSpec>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::Record::Body::Reader::getPolymorphic() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Decl::Record::Body::Builder::getPolymorphic() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Decl::Record::Body::Builder::setPolymorphic(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Decl::Record::Body::Reader::hasNonOverriddenMethods() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Record::Body::Builder::hasNonOverriddenMethods() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Decl::Record::Body::Reader::getNonOverriddenMethods() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Decl::Record::Body::Builder::getNonOverriddenMethods() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Decl::Record::Body::Builder::setNonOverriddenMethods( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline void Decl::Record::Body::Builder::setNonOverriddenMethods(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Decl::Record::Body::Builder::initNonOverriddenMethods(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Decl::Record::Body::Builder::adoptNonOverriddenMethods(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Decl::Record::Body::Builder::disownNonOverriddenMethods() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Decl::Record::Body::Reader::getIsAbstract() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool Decl::Record::Body::Builder::getIsAbstract() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Decl::Record::Body::Builder::setIsAbstract(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Decl::Method::Reader::getStatic() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Decl::Method::Builder::getStatic() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Decl::Method::Builder::setStatic(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Decl::Method::Reader::hasFunc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Method::Builder::hasFunc() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Function::Reader Decl::Method::Reader::getFunc() const {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Function>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Function::Builder Decl::Method::Builder::getFunc() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Function>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Decl::Function::Pipeline Decl::Method::Pipeline::getFunc() {
  return  ::stubs::Decl::Function::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Decl::Method::Builder::setFunc( ::stubs::Decl::Function::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Decl::Function>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Function::Builder Decl::Method::Builder::initFunc() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Function>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Method::Builder::adoptFunc(
    ::capnp::Orphan< ::stubs::Decl::Function>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Decl::Function>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Function> Decl::Method::Builder::disownFunc() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Function>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Method::Reader::hasThis() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Method::Builder::hasThis() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Type::Reader Decl::Method::Reader::getThis() const {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Type::Builder Decl::Method::Builder::getThis() {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Type::Pipeline Decl::Method::Pipeline::getThis() {
  return  ::stubs::Type::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Decl::Method::Builder::setThis( ::stubs::Type::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Type>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Type::Builder Decl::Method::Builder::initThis() {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Method::Builder::adoptThis(
    ::capnp::Orphan< ::stubs::Type>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Type>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Type> Decl::Method::Builder::disownThis() {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::Method::Reader::getImplicit() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool Decl::Method::Builder::getImplicit() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Decl::Method::Builder::setImplicit(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Decl::Method::Reader::getVirtual() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline bool Decl::Method::Builder::getVirtual() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Decl::Method::Builder::setVirtual(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Decl::Method::Reader::hasOverrides() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Method::Builder::hasOverrides() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>::Reader Decl::Method::Reader::getOverrides() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>::Builder Decl::Method::Builder::getOverrides() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Decl::Method::Builder::setOverrides( ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>::Builder Decl::Method::Builder::initOverrides(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Decl::Method::Builder::adoptOverrides(
    ::capnp::Orphan< ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>> Decl::Method::Builder::disownOverrides() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Method::Override,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Decl::Method::Override::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Method::Override::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Decl::Method::Override::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Decl::Method::Override::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Method::Override::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Decl::Method::Override::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Decl::Method::Override::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Decl::Method::Override::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Method::Override::Reader::hasBase() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Method::Override::Builder::hasBase() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::RecordRef::Reader Decl::Method::Override::Reader::getBase() const {
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::RecordRef::Builder Decl::Method::Override::Builder::getBase() {
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::RecordRef::Pipeline Decl::Method::Override::Pipeline::getBase() {
  return  ::stubs::RecordRef::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Decl::Method::Override::Builder::setBase( ::stubs::RecordRef::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::RecordRef>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::RecordRef::Builder Decl::Method::Override::Builder::initBase() {
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Method::Override::Builder::adoptBase(
    ::capnp::Orphan< ::stubs::RecordRef>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::RecordRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::RecordRef> Decl::Method::Override::Builder::disownBase() {
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::Ctor::Reader::hasMethod() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Ctor::Builder::hasMethod() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Method::Reader Decl::Ctor::Reader::getMethod() const {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Method::Builder Decl::Ctor::Builder::getMethod() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Decl::Method::Pipeline Decl::Ctor::Pipeline::getMethod() {
  return  ::stubs::Decl::Method::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Decl::Ctor::Builder::setMethod( ::stubs::Decl::Method::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Method::Builder Decl::Ctor::Builder::initMethod() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Ctor::Builder::adoptMethod(
    ::capnp::Orphan< ::stubs::Decl::Method>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Method> Decl::Ctor::Builder::disownMethod() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Ctor::Reader::hasInitList() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Ctor::Builder::hasInitList() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>::Reader Decl::Ctor::Reader::getInitList() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>::Builder Decl::Ctor::Builder::getInitList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Ctor::Builder::setInitList( ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>::Builder Decl::Ctor::Builder::initInitList(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Decl::Ctor::Builder::adoptInitList(
    ::capnp::Orphan< ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>> Decl::Ctor::Builder::disownInitList() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Ctor::CtorInit,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::Ctor::Reader::hasParent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Ctor::Builder::hasParent() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::RecordRef::Reader Decl::Ctor::Reader::getParent() const {
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::stubs::RecordRef::Builder Decl::Ctor::Builder::getParent() {
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::RecordRef::Pipeline Decl::Ctor::Pipeline::getParent() {
  return  ::stubs::RecordRef::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Decl::Ctor::Builder::setParent( ::stubs::RecordRef::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::RecordRef>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::stubs::RecordRef::Builder Decl::Ctor::Builder::initParent() {
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Decl::Ctor::Builder::adoptParent(
    ::capnp::Orphan< ::stubs::RecordRef>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::RecordRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::RecordRef> Decl::Ctor::Builder::disownParent() {
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Decl::Ctor::CtorInit::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Ctor::CtorInit::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Decl::Ctor::CtorInit::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Decl::Ctor::CtorInit::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Ctor::CtorInit::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Decl::Ctor::CtorInit::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Decl::Ctor::CtorInit::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Decl::Ctor::CtorInit::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Ctor::CtorInit::Reader::hasInit() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Ctor::CtorInit::Builder::hasInit() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Decl::Ctor::CtorInit::Reader::getInit() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Decl::Ctor::CtorInit::Builder::getInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Decl::Ctor::CtorInit::Pipeline::getInit() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Decl::Ctor::CtorInit::Builder::setInit( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Decl::Ctor::CtorInit::Builder::initInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Ctor::CtorInit::Builder::adoptInit(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Decl::Ctor::CtorInit::Builder::disownInit() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::Ctor::CtorInit::Reader::getIsWritten() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Decl::Ctor::CtorInit::Builder::getIsWritten() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Decl::Ctor::CtorInit::Builder::setIsWritten(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Decl::Dtor::Reader::hasMethod() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Dtor::Builder::hasMethod() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Decl::Method::Reader Decl::Dtor::Reader::getMethod() const {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Decl::Method::Builder Decl::Dtor::Builder::getMethod() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Decl::Method::Pipeline Decl::Dtor::Pipeline::getMethod() {
  return  ::stubs::Decl::Method::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Decl::Dtor::Builder::setMethod( ::stubs::Decl::Method::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Decl::Method::Builder Decl::Dtor::Builder::initMethod() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Dtor::Builder::adoptMethod(
    ::capnp::Orphan< ::stubs::Decl::Method>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Decl::Method> Decl::Dtor::Builder::disownMethod() {
  return ::capnp::_::PointerHelpers< ::stubs::Decl::Method>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Dtor::Reader::hasParent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Dtor::Builder::hasParent() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::RecordRef::Reader Decl::Dtor::Reader::getParent() const {
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::RecordRef::Builder Decl::Dtor::Builder::getParent() {
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::RecordRef::Pipeline Decl::Dtor::Pipeline::getParent() {
  return  ::stubs::RecordRef::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Decl::Dtor::Builder::setParent( ::stubs::RecordRef::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::RecordRef>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::RecordRef::Builder Decl::Dtor::Builder::initParent() {
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Dtor::Builder::adoptParent(
    ::capnp::Orphan< ::stubs::RecordRef>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::RecordRef>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::RecordRef> Decl::Dtor::Builder::disownParent() {
  return ::capnp::_::PointerHelpers< ::stubs::RecordRef>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::Typedef::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Typedef::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Type>::Reader Decl::Typedef::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Type>::Builder Decl::Typedef::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Type>::Pipeline Decl::Typedef::Pipeline::getType() {
  return  ::stubs::Node< ::stubs::Type>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Decl::Typedef::Builder::setType( ::stubs::Node< ::stubs::Type>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Type>::Builder Decl::Typedef::Builder::initType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Typedef::Builder::adoptType(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Type>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Type>> Decl::Typedef::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Type>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Typedef::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Typedef::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Decl::Typedef::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Decl::Typedef::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Typedef::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Decl::Typedef::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Decl::Typedef::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Decl::Typedef::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::Enum::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Enum::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Decl::Enum::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Decl::Enum::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Enum::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Decl::Enum::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Decl::Enum::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Decl::Enum::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Enum::Reader::hasFields() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Enum::Builder::hasFields() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>::Reader Decl::Enum::Reader::getFields() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>::Builder Decl::Enum::Builder::getFields() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Enum::Builder::setFields( ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>::Builder Decl::Enum::Builder::initFields(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Decl::Enum::Builder::adoptFields(
    ::capnp::Orphan< ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>> Decl::Enum::Builder::disownFields() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Decl::Enum::EnumField,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::Enum::EnumField::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Enum::EnumField::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Decl::Enum::EnumField::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Decl::Enum::EnumField::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Enum::EnumField::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Decl::Enum::EnumField::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Decl::Enum::EnumField::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Decl::Enum::EnumField::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Enum::EnumField::Reader::hasExpr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Enum::EnumField::Builder::hasExpr() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Decl::Enum::EnumField::Reader::getExpr() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Decl::Enum::EnumField::Builder::getExpr() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Decl::Enum::EnumField::Pipeline::getExpr() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Decl::Enum::EnumField::Builder::setExpr( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Decl::Enum::EnumField::Builder::initExpr() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Enum::EnumField::Builder::adoptExpr(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Decl::Enum::EnumField::Builder::disownExpr() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::Namespace::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Namespace::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Decl::Namespace::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Decl::Namespace::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::Namespace::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Decl::Namespace::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Decl::Namespace::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Decl::Namespace::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::Namespace::Reader::hasDecls() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::Namespace::Builder::hasDecls() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader Decl::Namespace::Reader::getDecls() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder Decl::Namespace::Builder::getDecls() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::Namespace::Builder::setDecls( ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder Decl::Namespace::Builder::initDecls(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Decl::Namespace::Builder::adoptDecls(
    ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>> Decl::Namespace::Builder::disownDecls() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::FunctionTemplate::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::FunctionTemplate::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Decl::FunctionTemplate::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Decl::FunctionTemplate::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Decl::FunctionTemplate::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Decl::FunctionTemplate::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Decl::FunctionTemplate::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Decl::FunctionTemplate::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Decl::FunctionTemplate::Reader::hasSpecs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::FunctionTemplate::Builder::hasSpecs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>::Reader Decl::FunctionTemplate::Reader::getSpecs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>::Builder Decl::FunctionTemplate::Builder::getSpecs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Decl::FunctionTemplate::Builder::setSpecs( ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>::Builder Decl::FunctionTemplate::Builder::initSpecs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Decl::FunctionTemplate::Builder::adoptSpecs(
    ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>> Decl::FunctionTemplate::Builder::disownSpecs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl::Function>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Decl::FunctionTemplate::Reader::hasContract() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Decl::FunctionTemplate::Builder::hasContract() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader Decl::FunctionTemplate::Reader::getContract() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder Decl::FunctionTemplate::Builder::getContract() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Decl::FunctionTemplate::Builder::setContract( ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder Decl::FunctionTemplate::Builder::initContract(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Decl::FunctionTemplate::Builder::adoptContract(
    ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>> Decl::FunctionTemplate::Builder::disownContract() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::stubs::Expr::Which Expr::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::stubs::Expr::Which Expr::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Expr::Reader::isUnionNotInitialized() const {
  return which() == Expr::UNION_NOT_INITIALIZED;
}
inline bool Expr::Builder::isUnionNotInitialized() {
  return which() == Expr::UNION_NOT_INITIALIZED;
}
inline  ::capnp::Void Expr::Reader::getUnionNotInitialized() const {
  KJ_IREQUIRE((which() == Expr::UNION_NOT_INITIALIZED),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Expr::Builder::getUnionNotInitialized() {
  KJ_IREQUIRE((which() == Expr::UNION_NOT_INITIALIZED),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Expr::Builder::setUnionNotInitialized( ::capnp::Void value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::UNION_NOT_INITIALIZED);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Expr::Reader::isUnaryOp() const {
  return which() == Expr::UNARY_OP;
}
inline bool Expr::Builder::isUnaryOp() {
  return which() == Expr::UNARY_OP;
}
inline bool Expr::Reader::hasUnaryOp() const {
  if (which() != Expr::UNARY_OP) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasUnaryOp() {
  if (which() != Expr::UNARY_OP) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Expr::UnaryOp::Reader Expr::Reader::getUnaryOp() const {
  KJ_IREQUIRE((which() == Expr::UNARY_OP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::UnaryOp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Expr::UnaryOp::Builder Expr::Builder::getUnaryOp() {
  KJ_IREQUIRE((which() == Expr::UNARY_OP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::UnaryOp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setUnaryOp( ::stubs::Expr::UnaryOp::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::UNARY_OP);
  ::capnp::_::PointerHelpers< ::stubs::Expr::UnaryOp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Expr::UnaryOp::Builder Expr::Builder::initUnaryOp() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::UNARY_OP);
  return ::capnp::_::PointerHelpers< ::stubs::Expr::UnaryOp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptUnaryOp(
    ::capnp::Orphan< ::stubs::Expr::UnaryOp>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::UNARY_OP);
  ::capnp::_::PointerHelpers< ::stubs::Expr::UnaryOp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Expr::UnaryOp> Expr::Builder::disownUnaryOp() {
  KJ_IREQUIRE((which() == Expr::UNARY_OP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::UnaryOp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isBinaryOp() const {
  return which() == Expr::BINARY_OP;
}
inline bool Expr::Builder::isBinaryOp() {
  return which() == Expr::BINARY_OP;
}
inline bool Expr::Reader::hasBinaryOp() const {
  if (which() != Expr::BINARY_OP) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasBinaryOp() {
  if (which() != Expr::BINARY_OP) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Expr::BinaryOp::Reader Expr::Reader::getBinaryOp() const {
  KJ_IREQUIRE((which() == Expr::BINARY_OP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::BinaryOp>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Expr::BinaryOp::Builder Expr::Builder::getBinaryOp() {
  KJ_IREQUIRE((which() == Expr::BINARY_OP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::BinaryOp>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setBinaryOp( ::stubs::Expr::BinaryOp::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::BINARY_OP);
  ::capnp::_::PointerHelpers< ::stubs::Expr::BinaryOp>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Expr::BinaryOp::Builder Expr::Builder::initBinaryOp() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::BINARY_OP);
  return ::capnp::_::PointerHelpers< ::stubs::Expr::BinaryOp>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptBinaryOp(
    ::capnp::Orphan< ::stubs::Expr::BinaryOp>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::BINARY_OP);
  ::capnp::_::PointerHelpers< ::stubs::Expr::BinaryOp>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Expr::BinaryOp> Expr::Builder::disownBinaryOp() {
  KJ_IREQUIRE((which() == Expr::BINARY_OP),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::BinaryOp>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isBoolLit() const {
  return which() == Expr::BOOL_LIT;
}
inline bool Expr::Builder::isBoolLit() {
  return which() == Expr::BOOL_LIT;
}
inline bool Expr::Reader::getBoolLit() const {
  KJ_IREQUIRE((which() == Expr::BOOL_LIT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline bool Expr::Builder::getBoolLit() {
  KJ_IREQUIRE((which() == Expr::BOOL_LIT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void Expr::Builder::setBoolLit(bool value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::BOOL_LIT);
  _builder.setDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline bool Expr::Reader::isIntLit() const {
  return which() == Expr::INT_LIT;
}
inline bool Expr::Builder::isIntLit() {
  return which() == Expr::INT_LIT;
}
inline bool Expr::Reader::hasIntLit() const {
  if (which() != Expr::INT_LIT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasIntLit() {
  if (which() != Expr::INT_LIT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Expr::IntLit::Reader Expr::Reader::getIntLit() const {
  KJ_IREQUIRE((which() == Expr::INT_LIT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::IntLit>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Expr::IntLit::Builder Expr::Builder::getIntLit() {
  KJ_IREQUIRE((which() == Expr::INT_LIT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::IntLit>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setIntLit( ::stubs::Expr::IntLit::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::INT_LIT);
  ::capnp::_::PointerHelpers< ::stubs::Expr::IntLit>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Expr::IntLit::Builder Expr::Builder::initIntLit() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::INT_LIT);
  return ::capnp::_::PointerHelpers< ::stubs::Expr::IntLit>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptIntLit(
    ::capnp::Orphan< ::stubs::Expr::IntLit>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::INT_LIT);
  ::capnp::_::PointerHelpers< ::stubs::Expr::IntLit>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Expr::IntLit> Expr::Builder::disownIntLit() {
  KJ_IREQUIRE((which() == Expr::INT_LIT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::IntLit>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isStringLit() const {
  return which() == Expr::STRING_LIT;
}
inline bool Expr::Builder::isStringLit() {
  return which() == Expr::STRING_LIT;
}
inline bool Expr::Reader::hasStringLit() const {
  if (which() != Expr::STRING_LIT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasStringLit() {
  if (which() != Expr::STRING_LIT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Expr::Reader::getStringLit() const {
  KJ_IREQUIRE((which() == Expr::STRING_LIT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Expr::Builder::getStringLit() {
  KJ_IREQUIRE((which() == Expr::STRING_LIT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setStringLit( ::capnp::Text::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::STRING_LIT);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Expr::Builder::initStringLit(unsigned int size) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::STRING_LIT);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Expr::Builder::adoptStringLit(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::STRING_LIT);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Expr::Builder::disownStringLit() {
  KJ_IREQUIRE((which() == Expr::STRING_LIT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isCall() const {
  return which() == Expr::CALL;
}
inline bool Expr::Builder::isCall() {
  return which() == Expr::CALL;
}
inline bool Expr::Reader::hasCall() const {
  if (which() != Expr::CALL) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasCall() {
  if (which() != Expr::CALL) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Expr::Call::Reader Expr::Reader::getCall() const {
  KJ_IREQUIRE((which() == Expr::CALL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Expr::Call::Builder Expr::Builder::getCall() {
  KJ_IREQUIRE((which() == Expr::CALL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setCall( ::stubs::Expr::Call::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::CALL);
  ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Expr::Call::Builder Expr::Builder::initCall() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::CALL);
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptCall(
    ::capnp::Orphan< ::stubs::Expr::Call>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::CALL);
  ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Expr::Call> Expr::Builder::disownCall() {
  KJ_IREQUIRE((which() == Expr::CALL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isDeclRef() const {
  return which() == Expr::DECL_REF;
}
inline bool Expr::Builder::isDeclRef() {
  return which() == Expr::DECL_REF;
}
inline bool Expr::Reader::hasDeclRef() const {
  if (which() != Expr::DECL_REF) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasDeclRef() {
  if (which() != Expr::DECL_REF) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Expr::Reader::getDeclRef() const {
  KJ_IREQUIRE((which() == Expr::DECL_REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Expr::Builder::getDeclRef() {
  KJ_IREQUIRE((which() == Expr::DECL_REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setDeclRef( ::capnp::Text::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::DECL_REF);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Expr::Builder::initDeclRef(unsigned int size) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::DECL_REF);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Expr::Builder::adoptDeclRef(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::DECL_REF);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Expr::Builder::disownDeclRef() {
  KJ_IREQUIRE((which() == Expr::DECL_REF),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isMember() const {
  return which() == Expr::MEMBER;
}
inline bool Expr::Builder::isMember() {
  return which() == Expr::MEMBER;
}
inline bool Expr::Reader::hasMember() const {
  if (which() != Expr::MEMBER) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasMember() {
  if (which() != Expr::MEMBER) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Expr::Member::Reader Expr::Reader::getMember() const {
  KJ_IREQUIRE((which() == Expr::MEMBER),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Member>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Expr::Member::Builder Expr::Builder::getMember() {
  KJ_IREQUIRE((which() == Expr::MEMBER),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Member>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setMember( ::stubs::Expr::Member::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::MEMBER);
  ::capnp::_::PointerHelpers< ::stubs::Expr::Member>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Expr::Member::Builder Expr::Builder::initMember() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::MEMBER);
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Member>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptMember(
    ::capnp::Orphan< ::stubs::Expr::Member>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::MEMBER);
  ::capnp::_::PointerHelpers< ::stubs::Expr::Member>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Expr::Member> Expr::Builder::disownMember() {
  KJ_IREQUIRE((which() == Expr::MEMBER),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Member>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isThis() const {
  return which() == Expr::THIS;
}
inline bool Expr::Builder::isThis() {
  return which() == Expr::THIS;
}
inline  ::capnp::Void Expr::Reader::getThis() const {
  KJ_IREQUIRE((which() == Expr::THIS),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Expr::Builder::getThis() {
  KJ_IREQUIRE((which() == Expr::THIS),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Expr::Builder::setThis( ::capnp::Void value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::THIS);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Expr::Reader::isMemberCall() const {
  return which() == Expr::MEMBER_CALL;
}
inline bool Expr::Builder::isMemberCall() {
  return which() == Expr::MEMBER_CALL;
}
inline bool Expr::Reader::hasMemberCall() const {
  if (which() != Expr::MEMBER_CALL) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasMemberCall() {
  if (which() != Expr::MEMBER_CALL) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Expr::MemberCall::Reader Expr::Reader::getMemberCall() const {
  KJ_IREQUIRE((which() == Expr::MEMBER_CALL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::MemberCall>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Expr::MemberCall::Builder Expr::Builder::getMemberCall() {
  KJ_IREQUIRE((which() == Expr::MEMBER_CALL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::MemberCall>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setMemberCall( ::stubs::Expr::MemberCall::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::MEMBER_CALL);
  ::capnp::_::PointerHelpers< ::stubs::Expr::MemberCall>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Expr::MemberCall::Builder Expr::Builder::initMemberCall() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::MEMBER_CALL);
  return ::capnp::_::PointerHelpers< ::stubs::Expr::MemberCall>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptMemberCall(
    ::capnp::Orphan< ::stubs::Expr::MemberCall>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::MEMBER_CALL);
  ::capnp::_::PointerHelpers< ::stubs::Expr::MemberCall>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Expr::MemberCall> Expr::Builder::disownMemberCall() {
  KJ_IREQUIRE((which() == Expr::MEMBER_CALL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::MemberCall>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isNew() const {
  return which() == Expr::NEW;
}
inline bool Expr::Builder::isNew() {
  return which() == Expr::NEW;
}
inline bool Expr::Reader::hasNew() const {
  if (which() != Expr::NEW) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasNew() {
  if (which() != Expr::NEW) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Expr::New::Reader Expr::Reader::getNew() const {
  KJ_IREQUIRE((which() == Expr::NEW),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::New>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Expr::New::Builder Expr::Builder::getNew() {
  KJ_IREQUIRE((which() == Expr::NEW),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::New>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setNew( ::stubs::Expr::New::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::NEW);
  ::capnp::_::PointerHelpers< ::stubs::Expr::New>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Expr::New::Builder Expr::Builder::initNew() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::NEW);
  return ::capnp::_::PointerHelpers< ::stubs::Expr::New>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptNew(
    ::capnp::Orphan< ::stubs::Expr::New>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::NEW);
  ::capnp::_::PointerHelpers< ::stubs::Expr::New>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Expr::New> Expr::Builder::disownNew() {
  KJ_IREQUIRE((which() == Expr::NEW),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::New>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isConstruct() const {
  return which() == Expr::CONSTRUCT;
}
inline bool Expr::Builder::isConstruct() {
  return which() == Expr::CONSTRUCT;
}
inline bool Expr::Reader::hasConstruct() const {
  if (which() != Expr::CONSTRUCT) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasConstruct() {
  if (which() != Expr::CONSTRUCT) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Expr::Construct::Reader Expr::Reader::getConstruct() const {
  KJ_IREQUIRE((which() == Expr::CONSTRUCT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Construct>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Expr::Construct::Builder Expr::Builder::getConstruct() {
  KJ_IREQUIRE((which() == Expr::CONSTRUCT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Construct>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setConstruct( ::stubs::Expr::Construct::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::CONSTRUCT);
  ::capnp::_::PointerHelpers< ::stubs::Expr::Construct>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Expr::Construct::Builder Expr::Builder::initConstruct() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::CONSTRUCT);
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Construct>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptConstruct(
    ::capnp::Orphan< ::stubs::Expr::Construct>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::CONSTRUCT);
  ::capnp::_::PointerHelpers< ::stubs::Expr::Construct>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Expr::Construct> Expr::Builder::disownConstruct() {
  KJ_IREQUIRE((which() == Expr::CONSTRUCT),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Construct>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isNullPtrLit() const {
  return which() == Expr::NULL_PTR_LIT;
}
inline bool Expr::Builder::isNullPtrLit() {
  return which() == Expr::NULL_PTR_LIT;
}
inline  ::capnp::Void Expr::Reader::getNullPtrLit() const {
  KJ_IREQUIRE((which() == Expr::NULL_PTR_LIT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Expr::Builder::getNullPtrLit() {
  KJ_IREQUIRE((which() == Expr::NULL_PTR_LIT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Expr::Builder::setNullPtrLit( ::capnp::Void value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::NULL_PTR_LIT);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Expr::Reader::isDelete() const {
  return which() == Expr::DELETE;
}
inline bool Expr::Builder::isDelete() {
  return which() == Expr::DELETE;
}
inline bool Expr::Reader::hasDelete() const {
  if (which() != Expr::DELETE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasDelete() {
  if (which() != Expr::DELETE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Expr::Reader::getDelete() const {
  KJ_IREQUIRE((which() == Expr::DELETE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::Builder::getDelete() {
  KJ_IREQUIRE((which() == Expr::DELETE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setDelete( ::stubs::Node< ::stubs::Expr>::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::DELETE);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::Builder::initDelete() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::DELETE);
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptDelete(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::DELETE);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Expr::Builder::disownDelete() {
  KJ_IREQUIRE((which() == Expr::DELETE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isTruncating() const {
  return which() == Expr::TRUNCATING;
}
inline bool Expr::Builder::isTruncating() {
  return which() == Expr::TRUNCATING;
}
inline bool Expr::Reader::hasTruncating() const {
  if (which() != Expr::TRUNCATING) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasTruncating() {
  if (which() != Expr::TRUNCATING) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Expr::Reader::getTruncating() const {
  KJ_IREQUIRE((which() == Expr::TRUNCATING),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::Builder::getTruncating() {
  KJ_IREQUIRE((which() == Expr::TRUNCATING),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setTruncating( ::stubs::Node< ::stubs::Expr>::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::TRUNCATING);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::Builder::initTruncating() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::TRUNCATING);
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptTruncating(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::TRUNCATING);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Expr::Builder::disownTruncating() {
  KJ_IREQUIRE((which() == Expr::TRUNCATING),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isLValueToRValue() const {
  return which() == Expr::L_VALUE_TO_R_VALUE;
}
inline bool Expr::Builder::isLValueToRValue() {
  return which() == Expr::L_VALUE_TO_R_VALUE;
}
inline bool Expr::Reader::hasLValueToRValue() const {
  if (which() != Expr::L_VALUE_TO_R_VALUE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasLValueToRValue() {
  if (which() != Expr::L_VALUE_TO_R_VALUE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Expr::Reader::getLValueToRValue() const {
  KJ_IREQUIRE((which() == Expr::L_VALUE_TO_R_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::Builder::getLValueToRValue() {
  KJ_IREQUIRE((which() == Expr::L_VALUE_TO_R_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setLValueToRValue( ::stubs::Node< ::stubs::Expr>::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::L_VALUE_TO_R_VALUE);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::Builder::initLValueToRValue() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::L_VALUE_TO_R_VALUE);
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptLValueToRValue(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::L_VALUE_TO_R_VALUE);
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Expr::Builder::disownLValueToRValue() {
  KJ_IREQUIRE((which() == Expr::L_VALUE_TO_R_VALUE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isDerivedToBase() const {
  return which() == Expr::DERIVED_TO_BASE;
}
inline bool Expr::Builder::isDerivedToBase() {
  return which() == Expr::DERIVED_TO_BASE;
}
inline bool Expr::Reader::hasDerivedToBase() const {
  if (which() != Expr::DERIVED_TO_BASE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasDerivedToBase() {
  if (which() != Expr::DERIVED_TO_BASE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Expr::StructToStruct::Reader Expr::Reader::getDerivedToBase() const {
  KJ_IREQUIRE((which() == Expr::DERIVED_TO_BASE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::StructToStruct>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Expr::StructToStruct::Builder Expr::Builder::getDerivedToBase() {
  KJ_IREQUIRE((which() == Expr::DERIVED_TO_BASE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::StructToStruct>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setDerivedToBase( ::stubs::Expr::StructToStruct::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::DERIVED_TO_BASE);
  ::capnp::_::PointerHelpers< ::stubs::Expr::StructToStruct>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Expr::StructToStruct::Builder Expr::Builder::initDerivedToBase() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::DERIVED_TO_BASE);
  return ::capnp::_::PointerHelpers< ::stubs::Expr::StructToStruct>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptDerivedToBase(
    ::capnp::Orphan< ::stubs::Expr::StructToStruct>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::DERIVED_TO_BASE);
  ::capnp::_::PointerHelpers< ::stubs::Expr::StructToStruct>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Expr::StructToStruct> Expr::Builder::disownDerivedToBase() {
  KJ_IREQUIRE((which() == Expr::DERIVED_TO_BASE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::StructToStruct>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isBaseToDerived() const {
  return which() == Expr::BASE_TO_DERIVED;
}
inline bool Expr::Builder::isBaseToDerived() {
  return which() == Expr::BASE_TO_DERIVED;
}
inline bool Expr::Reader::hasBaseToDerived() const {
  if (which() != Expr::BASE_TO_DERIVED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasBaseToDerived() {
  if (which() != Expr::BASE_TO_DERIVED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Expr::StructToStruct::Reader Expr::Reader::getBaseToDerived() const {
  KJ_IREQUIRE((which() == Expr::BASE_TO_DERIVED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::StructToStruct>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Expr::StructToStruct::Builder Expr::Builder::getBaseToDerived() {
  KJ_IREQUIRE((which() == Expr::BASE_TO_DERIVED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::StructToStruct>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setBaseToDerived( ::stubs::Expr::StructToStruct::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::BASE_TO_DERIVED);
  ::capnp::_::PointerHelpers< ::stubs::Expr::StructToStruct>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Expr::StructToStruct::Builder Expr::Builder::initBaseToDerived() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::BASE_TO_DERIVED);
  return ::capnp::_::PointerHelpers< ::stubs::Expr::StructToStruct>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptBaseToDerived(
    ::capnp::Orphan< ::stubs::Expr::StructToStruct>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::BASE_TO_DERIVED);
  ::capnp::_::PointerHelpers< ::stubs::Expr::StructToStruct>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Expr::StructToStruct> Expr::Builder::disownBaseToDerived() {
  KJ_IREQUIRE((which() == Expr::BASE_TO_DERIVED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::StructToStruct>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Reader::isOperatorCall() const {
  return which() == Expr::OPERATOR_CALL;
}
inline bool Expr::Builder::isOperatorCall() {
  return which() == Expr::OPERATOR_CALL;
}
inline bool Expr::Reader::hasOperatorCall() const {
  if (which() != Expr::OPERATOR_CALL) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Builder::hasOperatorCall() {
  if (which() != Expr::OPERATOR_CALL) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Expr::Call::Reader Expr::Reader::getOperatorCall() const {
  KJ_IREQUIRE((which() == Expr::OPERATOR_CALL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Expr::Call::Builder Expr::Builder::getOperatorCall() {
  KJ_IREQUIRE((which() == Expr::OPERATOR_CALL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::setOperatorCall( ::stubs::Expr::Call::Reader value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::OPERATOR_CALL);
  ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Expr::Call::Builder Expr::Builder::initOperatorCall() {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::OPERATOR_CALL);
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Builder::adoptOperatorCall(
    ::capnp::Orphan< ::stubs::Expr::Call>&& value) {
  _builder.setDataField<Expr::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Expr::OPERATOR_CALL);
  ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Expr::Call> Expr::Builder::disownOperatorCall() {
  KJ_IREQUIRE((which() == Expr::OPERATOR_CALL),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::UnaryOp::Reader::hasOperand() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::UnaryOp::Builder::hasOperand() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Expr::UnaryOp::Reader::getOperand() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::UnaryOp::Builder::getOperand() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Expr::UnaryOp::Pipeline::getOperand() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Expr::UnaryOp::Builder::setOperand( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::UnaryOp::Builder::initOperand() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::UnaryOp::Builder::adoptOperand(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Expr::UnaryOp::Builder::disownOperand() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::stubs::UnaryOpKind Expr::UnaryOp::Reader::getKind() const {
  return _reader.getDataField< ::stubs::UnaryOpKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::stubs::UnaryOpKind Expr::UnaryOp::Builder::getKind() {
  return _builder.getDataField< ::stubs::UnaryOpKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Expr::UnaryOp::Builder::setKind( ::stubs::UnaryOpKind value) {
  _builder.setDataField< ::stubs::UnaryOpKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Expr::BinaryOp::Reader::hasLhs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::BinaryOp::Builder::hasLhs() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Expr::BinaryOp::Reader::getLhs() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::BinaryOp::Builder::getLhs() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Expr::BinaryOp::Pipeline::getLhs() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Expr::BinaryOp::Builder::setLhs( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::BinaryOp::Builder::initLhs() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::BinaryOp::Builder::adoptLhs(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Expr::BinaryOp::Builder::disownLhs() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::BinaryOp::Reader::hasRhs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::BinaryOp::Builder::hasRhs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Expr::BinaryOp::Reader::getRhs() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::BinaryOp::Builder::getRhs() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Expr::BinaryOp::Pipeline::getRhs() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Expr::BinaryOp::Builder::setRhs( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::BinaryOp::Builder::initRhs() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Expr::BinaryOp::Builder::adoptRhs(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Expr::BinaryOp::Builder::disownRhs() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::stubs::BinaryOpKind Expr::BinaryOp::Reader::getKind() const {
  return _reader.getDataField< ::stubs::BinaryOpKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::stubs::BinaryOpKind Expr::BinaryOp::Builder::getKind() {
  return _builder.getDataField< ::stubs::BinaryOpKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Expr::BinaryOp::Builder::setKind( ::stubs::BinaryOpKind value) {
  _builder.setDataField< ::stubs::BinaryOpKind>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Expr::IntLit::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::IntLit::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Expr::IntLit::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Expr::IntLit::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::IntLit::Builder::setValue( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Expr::IntLit::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Expr::IntLit::Builder::adoptValue(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Expr::IntLit::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::IntLit::Reader::getUSuffix() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Expr::IntLit::Builder::getUSuffix() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Expr::IntLit::Builder::setUSuffix(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::stubs::SufKind Expr::IntLit::Reader::getLSuffix() const {
  return _reader.getDataField< ::stubs::SufKind>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::stubs::SufKind Expr::IntLit::Builder::getLSuffix() {
  return _builder.getDataField< ::stubs::SufKind>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Expr::IntLit::Builder::setLSuffix( ::stubs::SufKind value) {
  _builder.setDataField< ::stubs::SufKind>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::stubs::NbBase Expr::IntLit::Reader::getBase() const {
  return _reader.getDataField< ::stubs::NbBase>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::stubs::NbBase Expr::IntLit::Builder::getBase() {
  return _builder.getDataField< ::stubs::NbBase>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Expr::IntLit::Builder::setBase( ::stubs::NbBase value) {
  _builder.setDataField< ::stubs::NbBase>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Expr::Call::Reader::hasArgs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Call::Builder::hasArgs() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Reader Expr::Call::Reader::getArgs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Builder Expr::Call::Builder::getArgs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Call::Builder::setArgs( ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Builder Expr::Call::Builder::initArgs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Expr::Call::Builder::adoptArgs(
    ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>> Expr::Call::Builder::disownArgs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Call::Reader::hasCallee() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Call::Builder::hasCallee() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Expr::Call::Reader::getCallee() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::Call::Builder::getCallee() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Expr::Call::Pipeline::getCallee() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Expr::Call::Builder::setCallee( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::Call::Builder::initCallee() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Expr::Call::Builder::adoptCallee(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Expr::Call::Builder::disownCallee() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Expr::MemberCall::Reader::hasImplicitArg() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::MemberCall::Builder::hasImplicitArg() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Expr::MemberCall::Reader::getImplicitArg() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::MemberCall::Builder::getImplicitArg() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Expr::MemberCall::Pipeline::getImplicitArg() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Expr::MemberCall::Builder::setImplicitArg( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::MemberCall::Builder::initImplicitArg() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::MemberCall::Builder::adoptImplicitArg(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Expr::MemberCall::Builder::disownImplicitArg() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::MemberCall::Reader::getArrow() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Expr::MemberCall::Builder::getArrow() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Expr::MemberCall::Builder::setArrow(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Expr::MemberCall::Reader::hasCall() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::MemberCall::Builder::hasCall() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Expr::Call::Reader Expr::MemberCall::Reader::getCall() const {
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Expr::Call::Builder Expr::MemberCall::Builder::getCall() {
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Expr::Call::Pipeline Expr::MemberCall::Pipeline::getCall() {
  return  ::stubs::Expr::Call::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Expr::MemberCall::Builder::setCall( ::stubs::Expr::Call::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Expr::Call::Builder Expr::MemberCall::Builder::initCall() {
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Expr::MemberCall::Builder::adoptCall(
    ::capnp::Orphan< ::stubs::Expr::Call>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Expr::Call> Expr::MemberCall::Builder::disownCall() {
  return ::capnp::_::PointerHelpers< ::stubs::Expr::Call>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Expr::MemberCall::Reader::getTargetHasQualifier() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool Expr::MemberCall::Builder::getTargetHasQualifier() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Expr::MemberCall::Builder::setTargetHasQualifier(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Expr::Member::Reader::hasBase() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Member::Builder::hasBase() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Expr::Member::Reader::getBase() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::Member::Builder::getBase() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Expr::Member::Pipeline::getBase() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Expr::Member::Builder::setBase( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::Member::Builder::initBase() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Member::Builder::adoptBase(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Expr::Member::Builder::disownBase() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Member::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Member::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Expr::Member::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Expr::Member::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Expr::Member::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Expr::Member::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Expr::Member::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Expr::Member::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Expr::Member::Reader::getArrow() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Expr::Member::Builder::getArrow() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Expr::Member::Builder::setArrow(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Expr::Member::Reader::getBaseIsPointer() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline bool Expr::Member::Builder::getBaseIsPointer() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Expr::Member::Builder::setBaseIsPointer(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Expr::New::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::New::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Type::Reader Expr::New::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Type::Builder Expr::New::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Type::Pipeline Expr::New::Pipeline::getType() {
  return  ::stubs::Type::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Expr::New::Builder::setType( ::stubs::Type::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Type>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Type::Builder Expr::New::Builder::initType() {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::New::Builder::adoptType(
    ::capnp::Orphan< ::stubs::Type>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Type>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Type> Expr::New::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::New::Reader::hasExpr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::New::Builder::hasExpr() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Expr::New::Reader::getExpr() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::New::Builder::getExpr() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Expr::New::Pipeline::getExpr() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Expr::New::Builder::setExpr( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::New::Builder::initExpr() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Expr::New::Builder::adoptExpr(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Expr::New::Builder::disownExpr() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Expr::Construct::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Construct::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Expr::Construct::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Expr::Construct::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::Construct::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Expr::Construct::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Expr::Construct::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Expr::Construct::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::Construct::Reader::hasArgs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Construct::Builder::hasArgs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Reader Expr::Construct::Reader::getArgs() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Builder Expr::Construct::Builder::getArgs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Expr::Construct::Builder::setArgs( ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>::Builder Expr::Construct::Builder::initArgs(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Expr::Construct::Builder::adoptArgs(
    ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>> Expr::Construct::Builder::disownArgs() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Expr>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Expr::Construct::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::Construct::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Type::Reader Expr::Construct::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::stubs::Type::Builder Expr::Construct::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Type::Pipeline Expr::Construct::Pipeline::getType() {
  return  ::stubs::Type::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Expr::Construct::Builder::setType( ::stubs::Type::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Type>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Type::Builder Expr::Construct::Builder::initType() {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Expr::Construct::Builder::adoptType(
    ::capnp::Orphan< ::stubs::Type>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Type>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Type> Expr::Construct::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Expr::StructToStruct::Reader::hasExpr() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::StructToStruct::Builder::hasExpr() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Node< ::stubs::Expr>::Reader Expr::StructToStruct::Reader::getExpr() const {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::StructToStruct::Builder::getExpr() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Node< ::stubs::Expr>::Pipeline Expr::StructToStruct::Pipeline::getExpr() {
  return  ::stubs::Node< ::stubs::Expr>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Expr::StructToStruct::Builder::setExpr( ::stubs::Node< ::stubs::Expr>::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Node< ::stubs::Expr>::Builder Expr::StructToStruct::Builder::initExpr() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Expr::StructToStruct::Builder::adoptExpr(
    ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Node< ::stubs::Expr>> Expr::StructToStruct::Builder::disownExpr() {
  return ::capnp::_::PointerHelpers< ::stubs::Node< ::stubs::Expr>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Expr::StructToStruct::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Expr::StructToStruct::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Type::Reader Expr::StructToStruct::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::stubs::Type::Builder Expr::StructToStruct::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Type::Pipeline Expr::StructToStruct::Pipeline::getType() {
  return  ::stubs::Type::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Expr::StructToStruct::Builder::setType( ::stubs::Type::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Type>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Type::Builder Expr::StructToStruct::Builder::initType() {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Expr::StructToStruct::Builder::adoptType(
    ::capnp::Orphan< ::stubs::Type>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Type>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Type> Expr::StructToStruct::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::stubs::Type>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::stubs::Include::Which Include::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::stubs::Include::Which Include::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Include::Reader::isUnionNotInitialized() const {
  return which() == Include::UNION_NOT_INITIALIZED;
}
inline bool Include::Builder::isUnionNotInitialized() {
  return which() == Include::UNION_NOT_INITIALIZED;
}
inline  ::capnp::Void Include::Reader::getUnionNotInitialized() const {
  KJ_IREQUIRE((which() == Include::UNION_NOT_INITIALIZED),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Include::Builder::getUnionNotInitialized() {
  KJ_IREQUIRE((which() == Include::UNION_NOT_INITIALIZED),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Include::Builder::setUnionNotInitialized( ::capnp::Void value) {
  _builder.setDataField<Include::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Include::UNION_NOT_INITIALIZED);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Include::Reader::isRealInclude() const {
  return which() == Include::REAL_INCLUDE;
}
inline bool Include::Builder::isRealInclude() {
  return which() == Include::REAL_INCLUDE;
}
inline bool Include::Reader::hasRealInclude() const {
  if (which() != Include::REAL_INCLUDE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Include::Builder::hasRealInclude() {
  if (which() != Include::REAL_INCLUDE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Include::RealInclude::Reader Include::Reader::getRealInclude() const {
  KJ_IREQUIRE((which() == Include::REAL_INCLUDE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Include::RealInclude>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Include::RealInclude::Builder Include::Builder::getRealInclude() {
  KJ_IREQUIRE((which() == Include::REAL_INCLUDE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Include::RealInclude>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Include::Builder::setRealInclude( ::stubs::Include::RealInclude::Reader value) {
  _builder.setDataField<Include::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Include::REAL_INCLUDE);
  ::capnp::_::PointerHelpers< ::stubs::Include::RealInclude>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Include::RealInclude::Builder Include::Builder::initRealInclude() {
  _builder.setDataField<Include::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Include::REAL_INCLUDE);
  return ::capnp::_::PointerHelpers< ::stubs::Include::RealInclude>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Include::Builder::adoptRealInclude(
    ::capnp::Orphan< ::stubs::Include::RealInclude>&& value) {
  _builder.setDataField<Include::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Include::REAL_INCLUDE);
  ::capnp::_::PointerHelpers< ::stubs::Include::RealInclude>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Include::RealInclude> Include::Builder::disownRealInclude() {
  KJ_IREQUIRE((which() == Include::REAL_INCLUDE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Include::RealInclude>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Include::Reader::isGhostInclude() const {
  return which() == Include::GHOST_INCLUDE;
}
inline bool Include::Builder::isGhostInclude() {
  return which() == Include::GHOST_INCLUDE;
}
inline bool Include::Reader::hasGhostInclude() const {
  if (which() != Include::GHOST_INCLUDE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Include::Builder::hasGhostInclude() {
  if (which() != Include::GHOST_INCLUDE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Clause::Reader Include::Reader::getGhostInclude() const {
  KJ_IREQUIRE((which() == Include::GHOST_INCLUDE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Clause>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Clause::Builder Include::Builder::getGhostInclude() {
  KJ_IREQUIRE((which() == Include::GHOST_INCLUDE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Clause>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Include::Builder::setGhostInclude( ::stubs::Clause::Reader value) {
  _builder.setDataField<Include::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Include::GHOST_INCLUDE);
  ::capnp::_::PointerHelpers< ::stubs::Clause>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Clause::Builder Include::Builder::initGhostInclude() {
  _builder.setDataField<Include::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Include::GHOST_INCLUDE);
  return ::capnp::_::PointerHelpers< ::stubs::Clause>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Include::Builder::adoptGhostInclude(
    ::capnp::Orphan< ::stubs::Clause>&& value) {
  _builder.setDataField<Include::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Include::GHOST_INCLUDE);
  ::capnp::_::PointerHelpers< ::stubs::Clause>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Clause> Include::Builder::disownGhostInclude() {
  KJ_IREQUIRE((which() == Include::GHOST_INCLUDE),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::Clause>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Include::RealInclude::Reader::hasLoc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Include::RealInclude::Builder::hasLoc() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Loc::Reader Include::RealInclude::Reader::getLoc() const {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Loc::Builder Include::RealInclude::Builder::getLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Loc::Pipeline Include::RealInclude::Pipeline::getLoc() {
  return  ::stubs::Loc::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Include::RealInclude::Builder::setLoc( ::stubs::Loc::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Loc::Builder Include::RealInclude::Builder::initLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Include::RealInclude::Builder::adoptLoc(
    ::capnp::Orphan< ::stubs::Loc>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Loc> Include::RealInclude::Builder::disownLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Include::RealInclude::Reader::hasFileName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Include::RealInclude::Builder::hasFileName() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Include::RealInclude::Reader::getFileName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Include::RealInclude::Builder::getFileName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Include::RealInclude::Builder::setFileName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Include::RealInclude::Builder::initFileName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Include::RealInclude::Builder::adoptFileName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Include::RealInclude::Builder::disownFileName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint16_t Include::RealInclude::Reader::getFd() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Include::RealInclude::Builder::getFd() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Include::RealInclude::Builder::setFd( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Include::RealInclude::Reader::hasIncludes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Include::RealInclude::Builder::hasIncludes() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Reader Include::RealInclude::Reader::getIncludes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Builder Include::RealInclude::Builder::getIncludes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Include::RealInclude::Builder::setIncludes( ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Builder Include::RealInclude::Builder::initIncludes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Include::RealInclude::Builder::adoptIncludes(
    ::capnp::Orphan< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>> Include::RealInclude::Builder::disownIncludes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Include::RealInclude::Reader::getIsAngled() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}

inline bool Include::RealInclude::Builder::getIsAngled() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS);
}
inline void Include::RealInclude::Builder::setIsAngled(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<16>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t File::Reader::getFd() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t File::Builder::getFd() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void File::Builder::setFd( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool File::Reader::hasPath() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool File::Builder::hasPath() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader File::Reader::getPath() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder File::Builder::getPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void File::Builder::setPath( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder File::Builder::initPath(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void File::Builder::adoptPath(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> File::Builder::disownPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool File::Reader::hasDecls() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool File::Builder::hasDecls() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader File::Reader::getDecls() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder File::Builder::getDecls() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void File::Builder::setDecls( ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>::Builder File::Builder::initDecls(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void File::Builder::adoptDecls(
    ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>> File::Builder::disownDecls() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Node< ::stubs::Decl>,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint16_t TU::Reader::getMainFd() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t TU::Builder::getMainFd() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void TU::Builder::setMainFd( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool TU::Reader::hasIncludes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TU::Builder::hasIncludes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Reader TU::Reader::getIncludes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Builder TU::Builder::getIncludes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TU::Builder::setIncludes( ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>::Builder TU::Builder::initIncludes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void TU::Builder::adoptIncludes(
    ::capnp::Orphan< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>> TU::Builder::disownIncludes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Include,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TU::Reader::hasFiles() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TU::Builder::hasFiles() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>::Reader TU::Reader::getFiles() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>::Builder TU::Builder::getFiles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TU::Builder::setFiles( ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>::Builder TU::Builder::initFiles(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TU::Builder::adoptFiles(
    ::capnp::Orphan< ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>> TU::Builder::disownFiles() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::File,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TU::Reader::hasFailDirectives() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TU::Builder::hasFailDirectives() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader TU::Reader::getFailDirectives() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder TU::Builder::getFailDirectives() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TU::Builder::setFailDirectives( ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>::Builder TU::Builder::initFailDirectives(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void TU::Builder::adoptFailDirectives(
    ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>> TU::Builder::disownFailDirectives() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Clause,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Err::Reader::hasLoc() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Err::Builder::hasLoc() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::Loc::Reader Err::Reader::getLoc() const {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::Loc::Builder Err::Builder::getLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::Loc::Pipeline Err::Pipeline::getLoc() {
  return  ::stubs::Loc::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Err::Builder::setLoc( ::stubs::Loc::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::Loc::Builder Err::Builder::initLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Err::Builder::adoptLoc(
    ::capnp::Orphan< ::stubs::Loc>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::Loc>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::Loc> Err::Builder::disownLoc() {
  return ::capnp::_::PointerHelpers< ::stubs::Loc>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Err::Reader::hasReason() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Err::Builder::hasReason() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Err::Reader::getReason() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Err::Builder::getReason() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Err::Builder::setReason( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Err::Builder::initReason(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Err::Builder::adoptReason(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Err::Builder::disownReason() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool VfError::Reader::hasTu() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool VfError::Builder::hasTu() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::TU::Reader VfError::Reader::getTu() const {
  return ::capnp::_::PointerHelpers< ::stubs::TU>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::TU::Builder VfError::Builder::getTu() {
  return ::capnp::_::PointerHelpers< ::stubs::TU>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::stubs::TU::Pipeline VfError::Pipeline::getTu() {
  return  ::stubs::TU::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void VfError::Builder::setTu( ::stubs::TU::Reader value) {
  ::capnp::_::PointerHelpers< ::stubs::TU>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::TU::Builder VfError::Builder::initTu() {
  return ::capnp::_::PointerHelpers< ::stubs::TU>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void VfError::Builder::adoptTu(
    ::capnp::Orphan< ::stubs::TU>&& value) {
  ::capnp::_::PointerHelpers< ::stubs::TU>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::TU> VfError::Builder::disownTu() {
  return ::capnp::_::PointerHelpers< ::stubs::TU>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool VfError::Reader::hasErrors() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool VfError::Builder::hasErrors() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>::Reader VfError::Reader::getErrors() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>::Builder VfError::Builder::getErrors() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void VfError::Builder::setErrors( ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>::Builder VfError::Builder::initErrors(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void VfError::Builder::adoptErrors(
    ::capnp::Orphan< ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>> VfError::Builder::disownErrors() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::stubs::Err,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::stubs::SerResult::Which SerResult::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::stubs::SerResult::Which SerResult::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool SerResult::Reader::isOk() const {
  return which() == SerResult::OK;
}
inline bool SerResult::Builder::isOk() {
  return which() == SerResult::OK;
}
inline bool SerResult::Reader::hasOk() const {
  if (which() != SerResult::OK) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SerResult::Builder::hasOk() {
  if (which() != SerResult::OK) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::TU::Reader SerResult::Reader::getOk() const {
  KJ_IREQUIRE((which() == SerResult::OK),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::TU>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::TU::Builder SerResult::Builder::getOk() {
  KJ_IREQUIRE((which() == SerResult::OK),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::TU>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SerResult::Builder::setOk( ::stubs::TU::Reader value) {
  _builder.setDataField<SerResult::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SerResult::OK);
  ::capnp::_::PointerHelpers< ::stubs::TU>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::TU::Builder SerResult::Builder::initOk() {
  _builder.setDataField<SerResult::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SerResult::OK);
  return ::capnp::_::PointerHelpers< ::stubs::TU>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SerResult::Builder::adoptOk(
    ::capnp::Orphan< ::stubs::TU>&& value) {
  _builder.setDataField<SerResult::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SerResult::OK);
  ::capnp::_::PointerHelpers< ::stubs::TU>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::TU> SerResult::Builder::disownOk() {
  KJ_IREQUIRE((which() == SerResult::OK),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::TU>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SerResult::Reader::isClangError() const {
  return which() == SerResult::CLANG_ERROR;
}
inline bool SerResult::Builder::isClangError() {
  return which() == SerResult::CLANG_ERROR;
}
inline  ::capnp::Void SerResult::Reader::getClangError() const {
  KJ_IREQUIRE((which() == SerResult::CLANG_ERROR),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void SerResult::Builder::getClangError() {
  KJ_IREQUIRE((which() == SerResult::CLANG_ERROR),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void SerResult::Builder::setClangError( ::capnp::Void value) {
  _builder.setDataField<SerResult::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SerResult::CLANG_ERROR);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool SerResult::Reader::isVfError() const {
  return which() == SerResult::VF_ERROR;
}
inline bool SerResult::Builder::isVfError() {
  return which() == SerResult::VF_ERROR;
}
inline bool SerResult::Reader::hasVfError() const {
  if (which() != SerResult::VF_ERROR) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SerResult::Builder::hasVfError() {
  if (which() != SerResult::VF_ERROR) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::stubs::VfError::Reader SerResult::Reader::getVfError() const {
  KJ_IREQUIRE((which() == SerResult::VF_ERROR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::VfError>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::stubs::VfError::Builder SerResult::Builder::getVfError() {
  KJ_IREQUIRE((which() == SerResult::VF_ERROR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::VfError>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SerResult::Builder::setVfError( ::stubs::VfError::Reader value) {
  _builder.setDataField<SerResult::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SerResult::VF_ERROR);
  ::capnp::_::PointerHelpers< ::stubs::VfError>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::stubs::VfError::Builder SerResult::Builder::initVfError() {
  _builder.setDataField<SerResult::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SerResult::VF_ERROR);
  return ::capnp::_::PointerHelpers< ::stubs::VfError>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SerResult::Builder::adoptVfError(
    ::capnp::Orphan< ::stubs::VfError>&& value) {
  _builder.setDataField<SerResult::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, SerResult::VF_ERROR);
  ::capnp::_::PointerHelpers< ::stubs::VfError>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::stubs::VfError> SerResult::Builder::disownVfError() {
  KJ_IREQUIRE((which() == SerResult::VF_ERROR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::stubs::VfError>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

}  // namespace

CAPNP_END_HEADER

